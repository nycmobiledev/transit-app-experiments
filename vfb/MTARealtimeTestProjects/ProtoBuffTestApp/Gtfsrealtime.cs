// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!

#pragma warning disable 1591, 0612, 3021

#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
using System;

namespace transit_realtime
{
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Gtfsrealtime
    {
        #region Extension registration

        public static void RegisterAllExtensions(pb::ExtensionRegistry registry)
        {}

        #endregion

        #region Static variables

        internal static pbd::MessageDescriptor internal__static_transit_realtime_FeedMessage__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.FeedMessage, global::transit_realtime.FeedMessage.Builder>
            internal__static_transit_realtime_FeedMessage__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_FeedHeader__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.FeedHeader, global::transit_realtime.FeedHeader.Builder>
            internal__static_transit_realtime_FeedHeader__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_FeedEntity__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.FeedEntity, global::transit_realtime.FeedEntity.Builder>
            internal__static_transit_realtime_FeedEntity__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripUpdate__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.TripUpdate, global::transit_realtime.TripUpdate.Builder>
            internal__static_transit_realtime_TripUpdate__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.TripUpdate.Types.StopTimeEvent,
                    global::transit_realtime.TripUpdate.Types.StopTimeEvent.Builder>
            internal__static_transit_realtime_TripUpdate_StopTimeEvent__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.TripUpdate.Types.StopTimeUpdate,
                    global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Builder>
            internal__static_transit_realtime_TripUpdate_StopTimeUpdate__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_VehiclePosition__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.VehiclePosition, global::transit_realtime.VehiclePosition.Builder>
            internal__static_transit_realtime_VehiclePosition__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_Alert__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable<global::transit_realtime.Alert, global::transit_realtime.Alert.Builder>
            internal__static_transit_realtime_Alert__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_TimeRange__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.TimeRange, global::transit_realtime.TimeRange.Builder>
            internal__static_transit_realtime_TimeRange__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_Position__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.Position, global::transit_realtime.Position.Builder>
            internal__static_transit_realtime_Position__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripDescriptor__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.TripDescriptor, global::transit_realtime.TripDescriptor.Builder>
            internal__static_transit_realtime_TripDescriptor__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_VehicleDescriptor__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.VehicleDescriptor, global::transit_realtime.VehicleDescriptor.Builder>
            internal__static_transit_realtime_VehicleDescriptor__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_EntitySelector__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.EntitySelector, global::transit_realtime.EntitySelector.Builder>
            internal__static_transit_realtime_EntitySelector__FieldAccessorTable;

        internal static pbd::MessageDescriptor internal__static_transit_realtime_TranslatedString__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.TranslatedString, global::transit_realtime.TranslatedString.Builder>
            internal__static_transit_realtime_TranslatedString__FieldAccessorTable;

        internal static pbd::MessageDescriptor
            internal__static_transit_realtime_TranslatedString_Translation__Descriptor;

        internal static
            pb::FieldAccess.FieldAccessorTable
                <global::transit_realtime.TranslatedString.Types.Translation,
                    global::transit_realtime.TranslatedString.Types.Translation.Builder>
            internal__static_transit_realtime_TranslatedString_Translation__FieldAccessorTable;

        #endregion

        #region Descriptor

        private static pbd::FileDescriptor descriptor;

        static Gtfsrealtime()
        {
            byte[] descriptorData =
                global::System.Convert.FromBase64String("ChdNVEEvZ3Rmcy1yZWFsdGltZS5wcm90bxIQdHJhbnNpdF9yZWFsdGltZSJp" +
                                                        "CgtGZWVkTWVzc2FnZRIsCgZoZWFkZXIYASACKAsyHC50cmFuc2l0X3JlYWx0" +
                                                        "aW1lLkZlZWRIZWFkZXISLAoGZW50aXR5GAIgAygLMhwudHJhbnNpdF9yZWFs" +
                                                        "dGltZS5GZWVkRW50aXR5Is8BCgpGZWVkSGVhZGVyEh0KFWd0ZnNfcmVhbHRp" +
                                                        "bWVfdmVyc2lvbhgBIAIoCRJRCg5pbmNyZW1lbnRhbGl0eRgCIAEoDjIrLnRy" +
                                                        "YW5zaXRfcmVhbHRpbWUuRmVlZEhlYWRlci5JbmNyZW1lbnRhbGl0eToMRlVM" +
                                                        "TF9EQVRBU0VUEhEKCXRpbWVzdGFtcBgDIAEoBCI0Cg5JbmNyZW1lbnRhbGl0" +
                                                        "eRIQCgxGVUxMX0RBVEFTRVQQABIQCgxESUZGRVJFTlRJQUwQASoGCOgHENAP" +
                                                        "IsIBCgpGZWVkRW50aXR5EgoKAmlkGAEgAigJEhkKCmlzX2RlbGV0ZWQYAiAB" +
                                                        "KAg6BWZhbHNlEjEKC3RyaXBfdXBkYXRlGAMgASgLMhwudHJhbnNpdF9yZWFs" +
                                                        "dGltZS5UcmlwVXBkYXRlEjIKB3ZlaGljbGUYBCABKAsyIS50cmFuc2l0X3Jl" +
                                                        "YWx0aW1lLlZlaGljbGVQb3NpdGlvbhImCgVhbGVydBgFIAEoCzIXLnRyYW5z" +
                                                        "aXRfcmVhbHRpbWUuQWxlcnQiiwUKClRyaXBVcGRhdGUSLgoEdHJpcBgBIAIo" +
                                                        "CzIgLnRyYW5zaXRfcmVhbHRpbWUuVHJpcERlc2NyaXB0b3ISNAoHdmVoaWNs" +
                                                        "ZRgDIAEoCzIjLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZURlc2NyaXB0b3IS" +
                                                        "RQoQc3RvcF90aW1lX3VwZGF0ZRgCIAMoCzIrLnRyYW5zaXRfcmVhbHRpbWUu" +
                                                        "VHJpcFVwZGF0ZS5TdG9wVGltZVVwZGF0ZRIRCgl0aW1lc3RhbXAYBCABKAQa" +
                                                        "SQoNU3RvcFRpbWVFdmVudBINCgVkZWxheRgBIAEoBRIMCgR0aW1lGAIgASgD" +
                                                        "EhMKC3VuY2VydGFpbnR5GAMgASgFKgYI6AcQ0A8a6QIKDlN0b3BUaW1lVXBk" +
                                                        "YXRlEhUKDXN0b3Bfc2VxdWVuY2UYASABKA0SDwoHc3RvcF9pZBgEIAEoCRI7" +
                                                        "CgdhcnJpdmFsGAIgASgLMioudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRl" +
                                                        "LlN0b3BUaW1lRXZlbnQSPQoJZGVwYXJ0dXJlGAMgASgLMioudHJhbnNpdF9y" +
                                                        "ZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lRXZlbnQSagoVc2NoZWR1bGVf" +
                                                        "cmVsYXRpb25zaGlwGAUgASgOMkAudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBk" +
                                                        "YXRlLlN0b3BUaW1lVXBkYXRlLlNjaGVkdWxlUmVsYXRpb25zaGlwOglTQ0hF" +
                                                        "RFVMRUQiPwoUU2NoZWR1bGVSZWxhdGlvbnNoaXASDQoJU0NIRURVTEVEEAAS" +
                                                        "CwoHU0tJUFBFRBABEgsKB05PX0RBVEEQAioGCOgHENAPKgYI6AcQ0A8i4QQK" +
                                                        "D1ZlaGljbGVQb3NpdGlvbhIuCgR0cmlwGAEgASgLMiAudHJhbnNpdF9yZWFs" +
                                                        "dGltZS5UcmlwRGVzY3JpcHRvchI0Cgd2ZWhpY2xlGAggASgLMiMudHJhbnNp" +
                                                        "dF9yZWFsdGltZS5WZWhpY2xlRGVzY3JpcHRvchIsCghwb3NpdGlvbhgCIAEo" +
                                                        "CzIaLnRyYW5zaXRfcmVhbHRpbWUuUG9zaXRpb24SHQoVY3VycmVudF9zdG9w" +
                                                        "X3NlcXVlbmNlGAMgASgNEg8KB3N0b3BfaWQYByABKAkSWgoOY3VycmVudF9z" +
                                                        "dGF0dXMYBCABKA4yMy50cmFuc2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlv" +
                                                        "bi5WZWhpY2xlU3RvcFN0YXR1czoNSU5fVFJBTlNJVF9UTxIRCgl0aW1lc3Rh" +
                                                        "bXAYBSABKAQSSwoQY29uZ2VzdGlvbl9sZXZlbBgGIAEoDjIxLnRyYW5zaXRf" +
                                                        "cmVhbHRpbWUuVmVoaWNsZVBvc2l0aW9uLkNvbmdlc3Rpb25MZXZlbCJHChFW" +
                                                        "ZWhpY2xlU3RvcFN0YXR1cxIPCgtJTkNPTUlOR19BVBAAEg4KClNUT1BQRURf" +
                                                        "QVQQARIRCg1JTl9UUkFOU0lUX1RPEAIifQoPQ29uZ2VzdGlvbkxldmVsEhwK" +
                                                        "GFVOS05PV05fQ09OR0VTVElPTl9MRVZFTBAAEhQKEFJVTk5JTkdfU01PT1RI" +
                                                        "TFkQARIPCgtTVE9QX0FORF9HTxACEg4KCkNPTkdFU1RJT04QAxIVChFTRVZF" +
                                                        "UkVfQ09OR0VTVElPThAEKgYI6AcQ0A8itgYKBUFsZXJ0EjIKDWFjdGl2ZV9w" +
                                                        "ZXJpb2QYASADKAsyGy50cmFuc2l0X3JlYWx0aW1lLlRpbWVSYW5nZRI5Cg9p" +
                                                        "bmZvcm1lZF9lbnRpdHkYBSADKAsyIC50cmFuc2l0X3JlYWx0aW1lLkVudGl0" +
                                                        "eVNlbGVjdG9yEjsKBWNhdXNlGAYgASgOMh0udHJhbnNpdF9yZWFsdGltZS5B" +
                                                        "bGVydC5DYXVzZToNVU5LTk9XTl9DQVVTRRI+CgZlZmZlY3QYByABKA4yHi50" +
                                                        "cmFuc2l0X3JlYWx0aW1lLkFsZXJ0LkVmZmVjdDoOVU5LTk9XTl9FRkZFQ1QS" +
                                                        "LwoDdXJsGAggASgLMiIudHJhbnNpdF9yZWFsdGltZS5UcmFuc2xhdGVkU3Ry" +
                                                        "aW5nEjcKC2hlYWRlcl90ZXh0GAogASgLMiIudHJhbnNpdF9yZWFsdGltZS5U" +
                                                        "cmFuc2xhdGVkU3RyaW5nEjwKEGRlc2NyaXB0aW9uX3RleHQYCyABKAsyIi50" +
                                                        "cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmci2AEKBUNhdXNlEhEK" +
                                                        "DVVOS05PV05fQ0FVU0UQARIPCgtPVEhFUl9DQVVTRRACEhUKEVRFQ0hOSUNB" +
                                                        "TF9QUk9CTEVNEAMSCgoGU1RSSUtFEAQSEQoNREVNT05TVFJBVElPThAFEgwK" +
                                                        "CEFDQ0lERU5UEAYSCwoHSE9MSURBWRAHEgsKB1dFQVRIRVIQCBIPCgtNQUlO" +
                                                        "VEVOQU5DRRAJEhAKDENPTlNUUlVDVElPThAKEhMKD1BPTElDRV9BQ1RJVklU" +
                                                        "WRALEhUKEU1FRElDQUxfRU1FUkdFTkNZEAwitQEKBkVmZmVjdBIOCgpOT19T" +
                                                        "RVJWSUNFEAESEwoPUkVEVUNFRF9TRVJWSUNFEAISFgoSU0lHTklGSUNBTlRf" +
                                                        "REVMQVlTEAMSCgoGREVUT1VSEAQSFgoSQURESVRJT05BTF9TRVJWSUNFEAUS" +
                                                        "FAoQTU9ESUZJRURfU0VSVklDRRAGEhAKDE9USEVSX0VGRkVDVBAHEhIKDlVO" +
                                                        "S05PV05fRUZGRUNUEAgSDgoKU1RPUF9NT1ZFRBAJKgYI6AcQ0A8iJwoJVGlt" +
                                                        "ZVJhbmdlEg0KBXN0YXJ0GAEgASgEEgsKA2VuZBgCIAEoBCJpCghQb3NpdGlv" +
                                                        "bhIQCghsYXRpdHVkZRgBIAIoAhIRCglsb25naXR1ZGUYAiACKAISDwoHYmVh" +
                                                        "cmluZxgDIAEoAhIQCghvZG9tZXRlchgEIAEoARINCgVzcGVlZBgFIAEoAioG" +
                                                        "COgHENAPIpsCCg5UcmlwRGVzY3JpcHRvchIPCgd0cmlwX2lkGAEgASgJEhAK" +
                                                        "CHJvdXRlX2lkGAUgASgJEhIKCnN0YXJ0X3RpbWUYAiABKAkSEgoKc3RhcnRf" +
                                                        "ZGF0ZRgDIAEoCRJUChVzY2hlZHVsZV9yZWxhdGlvbnNoaXAYBCABKA4yNS50" +
                                                        "cmFuc2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9yLlNjaGVkdWxlUmVsYXRp" +
                                                        "b25zaGlwImAKFFNjaGVkdWxlUmVsYXRpb25zaGlwEg0KCVNDSEVEVUxFRBAA" +
                                                        "EgkKBUFEREVEEAESDwoLVU5TQ0hFRFVMRUQQAhIMCghDQU5DRUxFRBADEg8K" +
                                                        "C1JFUExBQ0VNRU5UEAUqBgjoBxDQDyJNChFWZWhpY2xlRGVzY3JpcHRvchIK" +
                                                        "CgJpZBgBIAEoCRINCgVsYWJlbBgCIAEoCRIVCg1saWNlbnNlX3BsYXRlGAMg" +
                                                        "ASgJKgYI6AcQ0A8ikgEKDkVudGl0eVNlbGVjdG9yEhEKCWFnZW5jeV9pZBgB" +
                                                        "IAEoCRIQCghyb3V0ZV9pZBgCIAEoCRISCgpyb3V0ZV90eXBlGAMgASgFEi4K" +
                                                        "BHRyaXAYBCABKAsyIC50cmFuc2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9y" +
                                                        "Eg8KB3N0b3BfaWQYBSABKAkqBgjoBxDQDyKGAQoQVHJhbnNsYXRlZFN0cmlu" +
                                                        "ZxJDCgt0cmFuc2xhdGlvbhgBIAMoCzIuLnRyYW5zaXRfcmVhbHRpbWUuVHJh" +
                                                        "bnNsYXRlZFN0cmluZy5UcmFuc2xhdGlvbhotCgtUcmFuc2xhdGlvbhIMCgR0" +
                                                        "ZXh0GAEgAigJEhAKCGxhbmd1YWdlGAIgASgJQh0KG2NvbS5nb29nbGUudHJh" +
                                                        "bnNpdC5yZWFsdGltZQ==");
            pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
                descriptor = root;
                internal__static_transit_realtime_FeedMessage__Descriptor = Descriptor.MessageTypes[0];
                internal__static_transit_realtime_FeedMessage__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.FeedMessage, global::transit_realtime.FeedMessage.Builder>(
                        internal__static_transit_realtime_FeedMessage__Descriptor, new string[] {"Header", "Entity",});
                internal__static_transit_realtime_FeedHeader__Descriptor = Descriptor.MessageTypes[1];
                internal__static_transit_realtime_FeedHeader__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.FeedHeader, global::transit_realtime.FeedHeader.Builder>(
                        internal__static_transit_realtime_FeedHeader__Descriptor,
                        new string[] {"GtfsRealtimeVersion", "Incrementality", "Timestamp",});
                internal__static_transit_realtime_FeedEntity__Descriptor = Descriptor.MessageTypes[2];
                internal__static_transit_realtime_FeedEntity__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.FeedEntity, global::transit_realtime.FeedEntity.Builder>(
                        internal__static_transit_realtime_FeedEntity__Descriptor,
                        new string[] {"Id", "IsDeleted", "TripUpdate", "Vehicle", "Alert",});
                internal__static_transit_realtime_TripUpdate__Descriptor = Descriptor.MessageTypes[3];
                internal__static_transit_realtime_TripUpdate__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.TripUpdate, global::transit_realtime.TripUpdate.Builder>(
                        internal__static_transit_realtime_TripUpdate__Descriptor,
                        new string[] {"Trip", "Vehicle", "StopTimeUpdate", "Timestamp",});
                internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor =
                    internal__static_transit_realtime_TripUpdate__Descriptor.NestedTypes[0];
                internal__static_transit_realtime_TripUpdate_StopTimeEvent__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.TripUpdate.Types.StopTimeEvent,
                            global::transit_realtime.TripUpdate.Types.StopTimeEvent.Builder>(
                        internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor,
                        new string[] {"Delay", "Time", "Uncertainty",});
                internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor =
                    internal__static_transit_realtime_TripUpdate__Descriptor.NestedTypes[1];
                internal__static_transit_realtime_TripUpdate_StopTimeUpdate__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.TripUpdate.Types.StopTimeUpdate,
                            global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Builder>(
                        internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor,
                        new string[] {"StopSequence", "StopId", "Arrival", "Departure", "ScheduleRelationship",});
                internal__static_transit_realtime_VehiclePosition__Descriptor = Descriptor.MessageTypes[4];
                internal__static_transit_realtime_VehiclePosition__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.VehiclePosition, global::transit_realtime.VehiclePosition.Builder>(
                        internal__static_transit_realtime_VehiclePosition__Descriptor,
                        new string[]
                        {
                            "Trip", "Vehicle", "Position", "CurrentStopSequence", "StopId", "CurrentStatus", "Timestamp",
                            "CongestionLevel",
                        });
                internal__static_transit_realtime_Alert__Descriptor = Descriptor.MessageTypes[5];
                internal__static_transit_realtime_Alert__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.Alert, global::transit_realtime.Alert.Builder>(
                        internal__static_transit_realtime_Alert__Descriptor,
                        new string[]
                        {"ActivePeriod", "InformedEntity", "Cause", "Effect", "Url", "HeaderText", "DescriptionText",});
                internal__static_transit_realtime_TimeRange__Descriptor = Descriptor.MessageTypes[6];
                internal__static_transit_realtime_TimeRange__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.TimeRange, global::transit_realtime.TimeRange.Builder>(
                        internal__static_transit_realtime_TimeRange__Descriptor, new string[] {"Start", "End",});
                internal__static_transit_realtime_Position__Descriptor = Descriptor.MessageTypes[7];
                internal__static_transit_realtime_Position__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.Position, global::transit_realtime.Position.Builder>(
                        internal__static_transit_realtime_Position__Descriptor,
                        new string[] {"Latitude", "Longitude", "Bearing", "Odometer", "Speed",});
                internal__static_transit_realtime_TripDescriptor__Descriptor = Descriptor.MessageTypes[8];
                internal__static_transit_realtime_TripDescriptor__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.TripDescriptor, global::transit_realtime.TripDescriptor.Builder>(
                        internal__static_transit_realtime_TripDescriptor__Descriptor,
                        new string[] {"TripId", "RouteId", "StartTime", "StartDate", "ScheduleRelationship",});
                internal__static_transit_realtime_VehicleDescriptor__Descriptor = Descriptor.MessageTypes[9];
                internal__static_transit_realtime_VehicleDescriptor__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.VehicleDescriptor, global::transit_realtime.VehicleDescriptor.Builder>
                        (internal__static_transit_realtime_VehicleDescriptor__Descriptor,
                            new string[] {"Id", "Label", "LicensePlate",});
                internal__static_transit_realtime_EntitySelector__Descriptor = Descriptor.MessageTypes[10];
                internal__static_transit_realtime_EntitySelector__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.EntitySelector, global::transit_realtime.EntitySelector.Builder>(
                        internal__static_transit_realtime_EntitySelector__Descriptor,
                        new string[] {"AgencyId", "RouteId", "RouteType", "Trip", "StopId",});
                internal__static_transit_realtime_TranslatedString__Descriptor = Descriptor.MessageTypes[11];
                internal__static_transit_realtime_TranslatedString__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.TranslatedString, global::transit_realtime.TranslatedString.Builder>(
                        internal__static_transit_realtime_TranslatedString__Descriptor, new string[] {"Translation",});
                internal__static_transit_realtime_TranslatedString_Translation__Descriptor =
                    internal__static_transit_realtime_TranslatedString__Descriptor.NestedTypes[0];
                internal__static_transit_realtime_TranslatedString_Translation__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable
                        <global::transit_realtime.TranslatedString.Types.Translation,
                            global::transit_realtime.TranslatedString.Types.Translation.Builder>(
                        internal__static_transit_realtime_TranslatedString_Translation__Descriptor,
                        new string[] {"Text", "Language",});
                return null;
            };
            pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData, new pbd::FileDescriptor[] {}, assigner);
        }

        public static pbd::FileDescriptor Descriptor
        {
            get { return descriptor; }
        }

        #endregion
    }

    #region Messages

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class FeedMessage : pb::GeneratedMessage<FeedMessage, FeedMessage.Builder>
    {
        public const int HeaderFieldNumber = 1;
        public const int EntityFieldNumber = 2;
        private static readonly FeedMessage defaultInstance = new FeedMessage().MakeReadOnly();
        private static readonly string[] _feedMessageFieldNames = new string[] {"entity", "header"};
        private static readonly uint[] _feedMessageFieldTags = new uint[] {18, 10};

        private pbc::PopsicleList<global::transit_realtime.FeedEntity> entity_ =
            new pbc::PopsicleList<global::transit_realtime.FeedEntity>();

        private bool hasHeader;
        private global::transit_realtime.FeedHeader header_;
        private int memoizedSerializedSize = -1;

        static FeedMessage()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private FeedMessage()
        {}

        public static FeedMessage DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override FeedMessage DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override FeedMessage ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_FeedMessage__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<FeedMessage, FeedMessage.Builder> InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_FeedMessage__FieldAccessorTable;
            }
        }

        public bool HasHeader
        {
            get { return hasHeader; }
        }

        public global::transit_realtime.FeedHeader Header
        {
            get { return header_ ?? global::transit_realtime.FeedHeader.DefaultInstance; }
        }

        public scg::IList<global::transit_realtime.FeedEntity> EntityList
        {
            get { return entity_; }
        }

        public int EntityCount
        {
            get { return entity_.Count; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasHeader) {
                    return false;
                }
                if (!Header.IsInitialized) {
                    return false;
                }
                foreach (var element in EntityList) {
                    if (!element.IsInitialized) {
                        return false;
                    }
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasHeader) {
                    size += pb::CodedOutputStream.ComputeMessageSize(1, Header);
                }
                foreach (var element in EntityList) {
                    size += pb::CodedOutputStream.ComputeMessageSize(2, element);
                }
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        public global::transit_realtime.FeedEntity GetEntity(int index)
        {
            return entity_[index];
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _feedMessageFieldNames;
            if (hasHeader) {
                output.WriteMessage(1, field_names[1], Header);
            }
            if (entity_.Count > 0) {
                output.WriteMessageArray(2, field_names[0], entity_);
            }
            UnknownFields.WriteTo(output);
        }

        public static FeedMessage ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static FeedMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static FeedMessage ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static FeedMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static FeedMessage ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static FeedMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static FeedMessage ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static FeedMessage ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static FeedMessage ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static FeedMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private FeedMessage MakeReadOnly()
        {
            entity_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(FeedMessage prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<FeedMessage, Builder>
        {
            private FeedMessage result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(FeedMessage cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override FeedMessage MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override FeedMessage DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasHeader
            {
                get { return result.hasHeader; }
            }

            public global::transit_realtime.FeedHeader Header
            {
                get { return result.Header; }
                set { SetHeader(value); }
            }

            public pbc::IPopsicleList<global::transit_realtime.FeedEntity> EntityList
            {
                get { return PrepareBuilder().entity_; }
            }

            public int EntityCount
            {
                get { return result.EntityCount; }
            }

            private FeedMessage PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    FeedMessage original = result;
                    result = new FeedMessage();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override FeedMessage BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is FeedMessage) {
                    return MergeFrom((FeedMessage) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(FeedMessage other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasHeader) {
                    MergeHeader(other.Header);
                }
                if (other.entity_.Count != 0) {
                    result.entity_.Add(other.entity_);
                }
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_feedMessageFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _feedMessageFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            global::transit_realtime.FeedHeader.Builder subBuilder =
                                global::transit_realtime.FeedHeader.CreateBuilder();
                            if (result.hasHeader) {
                                subBuilder.MergeFrom(Header);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Header = subBuilder.BuildPartial();
                            break;
                        }
                        case 18:
                        {
                            input.ReadMessageArray(tag, field_name, result.entity_,
                                global::transit_realtime.FeedEntity.DefaultInstance, extensionRegistry);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetHeader(global::transit_realtime.FeedHeader value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasHeader = true;
                result.header_ = value;
                return this;
            }

            public Builder SetHeader(global::transit_realtime.FeedHeader.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasHeader = true;
                result.header_ = builderForValue.Build();
                return this;
            }

            public Builder MergeHeader(global::transit_realtime.FeedHeader value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasHeader && result.header_ != global::transit_realtime.FeedHeader.DefaultInstance) {
                    result.header_ =
                        global::transit_realtime.FeedHeader.CreateBuilder(result.header_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.header_ = value;
                }
                result.hasHeader = true;
                return this;
            }

            public Builder ClearHeader()
            {
                PrepareBuilder();
                result.hasHeader = false;
                result.header_ = null;
                return this;
            }

            public global::transit_realtime.FeedEntity GetEntity(int index)
            {
                return result.GetEntity(index);
            }

            public Builder SetEntity(int index, global::transit_realtime.FeedEntity value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.entity_[index] = value;
                return this;
            }

            public Builder SetEntity(int index, global::transit_realtime.FeedEntity.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.entity_[index] = builderForValue.Build();
                return this;
            }

            public Builder AddEntity(global::transit_realtime.FeedEntity value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.entity_.Add(value);
                return this;
            }

            public Builder AddEntity(global::transit_realtime.FeedEntity.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.entity_.Add(builderForValue.Build());
                return this;
            }

            public Builder AddRangeEntity(scg::IEnumerable<global::transit_realtime.FeedEntity> values)
            {
                PrepareBuilder();
                result.entity_.Add(values);
                return this;
            }

            public Builder ClearEntity()
            {
                PrepareBuilder();
                result.entity_.Clear();
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class FeedHeader : pb::ExtendableMessage<FeedHeader, FeedHeader.Builder>
    {
        public const int GtfsRealtimeVersionFieldNumber = 1;
        public const int IncrementalityFieldNumber = 2;
        public const int TimestampFieldNumber = 3;
        private static readonly FeedHeader defaultInstance = new FeedHeader().MakeReadOnly();

        private static readonly string[] _feedHeaderFieldNames = new string[]
        {"gtfs_realtime_version", "incrementality", "timestamp"};

        private static readonly uint[] _feedHeaderFieldTags = new uint[] {10, 16, 24};
        private string gtfsRealtimeVersion_ = "";
        private bool hasGtfsRealtimeVersion;
        private bool hasIncrementality;
        private bool hasTimestamp;

        private global::transit_realtime.FeedHeader.Types.Incrementality incrementality_ =
            global::transit_realtime.FeedHeader.Types.Incrementality.FULL_DATASET;

        private int memoizedSerializedSize = -1;
        private ulong timestamp_;

        static FeedHeader()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private FeedHeader()
        {}

        public static FeedHeader DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override FeedHeader DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override FeedHeader ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_FeedHeader__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<FeedHeader, FeedHeader.Builder> InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_FeedHeader__FieldAccessorTable;
            }
        }

        public bool HasGtfsRealtimeVersion
        {
            get { return hasGtfsRealtimeVersion; }
        }

        public string GtfsRealtimeVersion
        {
            get { return gtfsRealtimeVersion_; }
        }

        public bool HasIncrementality
        {
            get { return hasIncrementality; }
        }

        public global::transit_realtime.FeedHeader.Types.Incrementality Incrementality
        {
            get { return incrementality_; }
        }

        public bool HasTimestamp
        {
            get { return hasTimestamp; }
        }

        [global::System.CLSCompliant(false)]
        public ulong Timestamp
        {
            get { return timestamp_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasGtfsRealtimeVersion) {
                    return false;
                }
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasGtfsRealtimeVersion) {
                    size += pb::CodedOutputStream.ComputeStringSize(1, GtfsRealtimeVersion);
                }
                if (hasIncrementality) {
                    size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Incrementality);
                }
                if (hasTimestamp) {
                    size += pb::CodedOutputStream.ComputeUInt64Size(3, Timestamp);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        #region Nested types

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum Incrementality
            {
                FULL_DATASET = 0,
                DIFFERENTIAL = 1,
            }
        }

        #endregion

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _feedHeaderFieldNames;
            pb::ExtendableMessage<FeedHeader, FeedHeader.Builder>.ExtensionWriter extensionWriter =
                CreateExtensionWriter(this);
            if (hasGtfsRealtimeVersion) {
                output.WriteString(1, field_names[0], GtfsRealtimeVersion);
            }
            if (hasIncrementality) {
                output.WriteEnum(2, field_names[1], (int) Incrementality, Incrementality);
            }
            if (hasTimestamp) {
                output.WriteUInt64(3, field_names[2], Timestamp);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static FeedHeader ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static FeedHeader ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static FeedHeader ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static FeedHeader ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static FeedHeader ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static FeedHeader ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static FeedHeader ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static FeedHeader ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static FeedHeader ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static FeedHeader ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private FeedHeader MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(FeedHeader prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<FeedHeader, Builder>
        {
            private FeedHeader result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(FeedHeader cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override FeedHeader MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override FeedHeader DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasGtfsRealtimeVersion
            {
                get { return result.hasGtfsRealtimeVersion; }
            }

            public string GtfsRealtimeVersion
            {
                get { return result.GtfsRealtimeVersion; }
                set { SetGtfsRealtimeVersion(value); }
            }

            public bool HasIncrementality
            {
                get { return result.hasIncrementality; }
            }

            public global::transit_realtime.FeedHeader.Types.Incrementality Incrementality
            {
                get { return result.Incrementality; }
                set { SetIncrementality(value); }
            }

            public bool HasTimestamp
            {
                get { return result.hasTimestamp; }
            }

            [global::System.CLSCompliant(false)]
            public ulong Timestamp
            {
                get { return result.Timestamp; }
                set { SetTimestamp(value); }
            }

            private FeedHeader PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    FeedHeader original = result;
                    result = new FeedHeader();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override FeedHeader BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is FeedHeader) {
                    return MergeFrom((FeedHeader) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(FeedHeader other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasGtfsRealtimeVersion) {
                    GtfsRealtimeVersion = other.GtfsRealtimeVersion;
                }
                if (other.HasIncrementality) {
                    Incrementality = other.Incrementality;
                }
                if (other.HasTimestamp) {
                    Timestamp = other.Timestamp;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_feedHeaderFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _feedHeaderFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            result.hasGtfsRealtimeVersion = input.ReadString(ref result.gtfsRealtimeVersion_);
                            break;
                        }
                        case 16:
                        {
                            object unknown;
                            if (input.ReadEnum(ref result.incrementality_, out unknown)) {
                                result.hasIncrementality = true;
                            } else if (unknown is int) {
                                if (unknownFields == null) {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                unknownFields.MergeVarintField(2, (ulong) (int) unknown);
                            }
                            break;
                        }
                        case 24:
                        {
                            result.hasTimestamp = input.ReadUInt64(ref result.timestamp_);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetGtfsRealtimeVersion(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasGtfsRealtimeVersion = true;
                result.gtfsRealtimeVersion_ = value;
                return this;
            }

            public Builder ClearGtfsRealtimeVersion()
            {
                PrepareBuilder();
                result.hasGtfsRealtimeVersion = false;
                result.gtfsRealtimeVersion_ = "";
                return this;
            }

            public Builder SetIncrementality(global::transit_realtime.FeedHeader.Types.Incrementality value)
            {
                PrepareBuilder();
                result.hasIncrementality = true;
                result.incrementality_ = value;
                return this;
            }

            public Builder ClearIncrementality()
            {
                PrepareBuilder();
                result.hasIncrementality = false;
                result.incrementality_ = global::transit_realtime.FeedHeader.Types.Incrementality.FULL_DATASET;
                return this;
            }

            [global::System.CLSCompliant(false)]
            public Builder SetTimestamp(ulong value)
            {
                PrepareBuilder();
                result.hasTimestamp = true;
                result.timestamp_ = value;
                return this;
            }

            public Builder ClearTimestamp()
            {
                PrepareBuilder();
                result.hasTimestamp = false;
                result.timestamp_ = 0UL;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class FeedEntity : pb::GeneratedMessage<FeedEntity, FeedEntity.Builder>
    {
        public const int IdFieldNumber = 1;
        public const int IsDeletedFieldNumber = 2;
        public const int TripUpdateFieldNumber = 3;
        public const int VehicleFieldNumber = 4;
        public const int AlertFieldNumber = 5;
        private static readonly FeedEntity defaultInstance = new FeedEntity().MakeReadOnly();

        private static readonly string[] _feedEntityFieldNames = new string[]
        {"alert", "id", "is_deleted", "trip_update", "vehicle"};

        private static readonly uint[] _feedEntityFieldTags = new uint[] {42, 10, 16, 26, 34};
        private global::transit_realtime.Alert alert_;
        private bool hasAlert;
        private bool hasId;
        private bool hasIsDeleted;
        private bool hasTripUpdate;
        private bool hasVehicle;
        private string id_ = "";
        private bool isDeleted_;
        private int memoizedSerializedSize = -1;
        private global::transit_realtime.TripUpdate tripUpdate_;
        private global::transit_realtime.VehiclePosition vehicle_;

        static FeedEntity()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private FeedEntity()
        {}

        public static FeedEntity DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override FeedEntity DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override FeedEntity ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_FeedEntity__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<FeedEntity, FeedEntity.Builder> InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_FeedEntity__FieldAccessorTable;
            }
        }

        public bool HasId
        {
            get { return hasId; }
        }

        public string Id
        {
            get { return id_; }
        }

        public bool HasIsDeleted
        {
            get { return hasIsDeleted; }
        }

        public bool IsDeleted
        {
            get { return isDeleted_; }
        }

        public bool HasTripUpdate
        {
            get { return hasTripUpdate; }
        }

        public global::transit_realtime.TripUpdate TripUpdate
        {
            get { return tripUpdate_ ?? global::transit_realtime.TripUpdate.DefaultInstance; }
        }

        public bool HasVehicle
        {
            get { return hasVehicle; }
        }

        public global::transit_realtime.VehiclePosition Vehicle
        {
            get { return vehicle_ ?? global::transit_realtime.VehiclePosition.DefaultInstance; }
        }

        public bool HasAlert
        {
            get { return hasAlert; }
        }

        public global::transit_realtime.Alert Alert
        {
            get { return alert_ ?? global::transit_realtime.Alert.DefaultInstance; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasId) {
                    return false;
                }
                if (HasTripUpdate) {
                    if (!TripUpdate.IsInitialized) {
                        return false;
                    }
                }
                if (HasVehicle) {
                    if (!Vehicle.IsInitialized) {
                        return false;
                    }
                }
                if (HasAlert) {
                    if (!Alert.IsInitialized) {
                        return false;
                    }
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasId) {
                    size += pb::CodedOutputStream.ComputeStringSize(1, Id);
                }
                if (hasIsDeleted) {
                    size += pb::CodedOutputStream.ComputeBoolSize(2, IsDeleted);
                }
                if (hasTripUpdate) {
                    size += pb::CodedOutputStream.ComputeMessageSize(3, TripUpdate);
                }
                if (hasVehicle) {
                    size += pb::CodedOutputStream.ComputeMessageSize(4, Vehicle);
                }
                if (hasAlert) {
                    size += pb::CodedOutputStream.ComputeMessageSize(5, Alert);
                }
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _feedEntityFieldNames;
            if (hasId) {
                output.WriteString(1, field_names[1], Id);
            }
            if (hasIsDeleted) {
                output.WriteBool(2, field_names[2], IsDeleted);
            }
            if (hasTripUpdate) {
                output.WriteMessage(3, field_names[3], TripUpdate);
            }
            if (hasVehicle) {
                output.WriteMessage(4, field_names[4], Vehicle);
            }
            if (hasAlert) {
                output.WriteMessage(5, field_names[0], Alert);
            }
            UnknownFields.WriteTo(output);
        }

        public static FeedEntity ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static FeedEntity ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static FeedEntity ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static FeedEntity ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static FeedEntity ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static FeedEntity ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static FeedEntity ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static FeedEntity ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static FeedEntity ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static FeedEntity ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private FeedEntity MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(FeedEntity prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<FeedEntity, Builder>
        {
            private FeedEntity result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(FeedEntity cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override FeedEntity MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override FeedEntity DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasId
            {
                get { return result.hasId; }
            }

            public string Id
            {
                get { return result.Id; }
                set { SetId(value); }
            }

            public bool HasIsDeleted
            {
                get { return result.hasIsDeleted; }
            }

            public bool IsDeleted
            {
                get { return result.IsDeleted; }
                set { SetIsDeleted(value); }
            }

            public bool HasTripUpdate
            {
                get { return result.hasTripUpdate; }
            }

            public global::transit_realtime.TripUpdate TripUpdate
            {
                get { return result.TripUpdate; }
                set { SetTripUpdate(value); }
            }

            public bool HasVehicle
            {
                get { return result.hasVehicle; }
            }

            public global::transit_realtime.VehiclePosition Vehicle
            {
                get { return result.Vehicle; }
                set { SetVehicle(value); }
            }

            public bool HasAlert
            {
                get { return result.hasAlert; }
            }

            public global::transit_realtime.Alert Alert
            {
                get { return result.Alert; }
                set { SetAlert(value); }
            }

            private FeedEntity PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    FeedEntity original = result;
                    result = new FeedEntity();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override FeedEntity BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is FeedEntity) {
                    return MergeFrom((FeedEntity) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(FeedEntity other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasId) {
                    Id = other.Id;
                }
                if (other.HasIsDeleted) {
                    IsDeleted = other.IsDeleted;
                }
                if (other.HasTripUpdate) {
                    MergeTripUpdate(other.TripUpdate);
                }
                if (other.HasVehicle) {
                    MergeVehicle(other.Vehicle);
                }
                if (other.HasAlert) {
                    MergeAlert(other.Alert);
                }
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_feedEntityFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _feedEntityFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            result.hasId = input.ReadString(ref result.id_);
                            break;
                        }
                        case 16:
                        {
                            result.hasIsDeleted = input.ReadBool(ref result.isDeleted_);
                            break;
                        }
                        case 26:
                        {
                            global::transit_realtime.TripUpdate.Builder subBuilder =
                                global::transit_realtime.TripUpdate.CreateBuilder();
                            if (result.hasTripUpdate) {
                                subBuilder.MergeFrom(TripUpdate);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            TripUpdate = subBuilder.BuildPartial();
                            break;
                        }
                        case 34:
                        {
                            global::transit_realtime.VehiclePosition.Builder subBuilder =
                                global::transit_realtime.VehiclePosition.CreateBuilder();
                            if (result.hasVehicle) {
                                subBuilder.MergeFrom(Vehicle);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Vehicle = subBuilder.BuildPartial();
                            break;
                        }
                        case 42:
                        {
                            global::transit_realtime.Alert.Builder subBuilder =
                                global::transit_realtime.Alert.CreateBuilder();
                            if (result.hasAlert) {
                                subBuilder.MergeFrom(Alert);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Alert = subBuilder.BuildPartial();
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasId = true;
                result.id_ = value;
                return this;
            }

            public Builder ClearId()
            {
                PrepareBuilder();
                result.hasId = false;
                result.id_ = "";
                return this;
            }

            public Builder SetIsDeleted(bool value)
            {
                PrepareBuilder();
                result.hasIsDeleted = true;
                result.isDeleted_ = value;
                return this;
            }

            public Builder ClearIsDeleted()
            {
                PrepareBuilder();
                result.hasIsDeleted = false;
                result.isDeleted_ = false;
                return this;
            }

            public Builder SetTripUpdate(global::transit_realtime.TripUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTripUpdate = true;
                result.tripUpdate_ = value;
                return this;
            }

            public Builder SetTripUpdate(global::transit_realtime.TripUpdate.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTripUpdate = true;
                result.tripUpdate_ = builderForValue.Build();
                return this;
            }

            public Builder MergeTripUpdate(global::transit_realtime.TripUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTripUpdate && result.tripUpdate_ != global::transit_realtime.TripUpdate.DefaultInstance) {
                    result.tripUpdate_ =
                        global::transit_realtime.TripUpdate.CreateBuilder(result.tripUpdate_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.tripUpdate_ = value;
                }
                result.hasTripUpdate = true;
                return this;
            }

            public Builder ClearTripUpdate()
            {
                PrepareBuilder();
                result.hasTripUpdate = false;
                result.tripUpdate_ = null;
                return this;
            }

            public Builder SetVehicle(global::transit_realtime.VehiclePosition value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = value;
                return this;
            }

            public Builder SetVehicle(global::transit_realtime.VehiclePosition.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = builderForValue.Build();
                return this;
            }

            public Builder MergeVehicle(global::transit_realtime.VehiclePosition value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasVehicle && result.vehicle_ != global::transit_realtime.VehiclePosition.DefaultInstance) {
                    result.vehicle_ =
                        global::transit_realtime.VehiclePosition.CreateBuilder(result.vehicle_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.vehicle_ = value;
                }
                result.hasVehicle = true;
                return this;
            }

            public Builder ClearVehicle()
            {
                PrepareBuilder();
                result.hasVehicle = false;
                result.vehicle_ = null;
                return this;
            }

            public Builder SetAlert(global::transit_realtime.Alert value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasAlert = true;
                result.alert_ = value;
                return this;
            }

            public Builder SetAlert(global::transit_realtime.Alert.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasAlert = true;
                result.alert_ = builderForValue.Build();
                return this;
            }

            public Builder MergeAlert(global::transit_realtime.Alert value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasAlert && result.alert_ != global::transit_realtime.Alert.DefaultInstance) {
                    result.alert_ =
                        global::transit_realtime.Alert.CreateBuilder(result.alert_).MergeFrom(value).BuildPartial();
                } else {
                    result.alert_ = value;
                }
                result.hasAlert = true;
                return this;
            }

            public Builder ClearAlert()
            {
                PrepareBuilder();
                result.hasAlert = false;
                result.alert_ = null;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TripUpdate : pb::ExtendableMessage<TripUpdate, TripUpdate.Builder>
    {
        public const int TripFieldNumber = 1;
        public const int VehicleFieldNumber = 3;
        public const int StopTimeUpdateFieldNumber = 2;
        public const int TimestampFieldNumber = 4;
        private static readonly TripUpdate defaultInstance = new TripUpdate().MakeReadOnly();

        private static readonly string[] _tripUpdateFieldNames = new string[]
        {"stop_time_update", "timestamp", "trip", "vehicle"};

        private static readonly uint[] _tripUpdateFieldTags = new uint[] {18, 32, 10, 26};
        private bool hasTimestamp;
        private bool hasTrip;
        private bool hasVehicle;
        private int memoizedSerializedSize = -1;

        private pbc::PopsicleList<global::transit_realtime.TripUpdate.Types.StopTimeUpdate> stopTimeUpdate_ =
            new pbc::PopsicleList<global::transit_realtime.TripUpdate.Types.StopTimeUpdate>();

        private ulong timestamp_;
        private global::transit_realtime.TripDescriptor trip_;
        private global::transit_realtime.VehicleDescriptor vehicle_;

        static TripUpdate()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private TripUpdate()
        {}

        public static TripUpdate DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TripUpdate DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TripUpdate ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_TripUpdate__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TripUpdate, TripUpdate.Builder> InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_TripUpdate__FieldAccessorTable;
            }
        }

        public bool HasTrip
        {
            get { return hasTrip; }
        }

        public global::transit_realtime.TripDescriptor Trip
        {
            get { return trip_ ?? global::transit_realtime.TripDescriptor.DefaultInstance; }
        }

        public bool HasVehicle
        {
            get { return hasVehicle; }
        }

        public global::transit_realtime.VehicleDescriptor Vehicle
        {
            get { return vehicle_ ?? global::transit_realtime.VehicleDescriptor.DefaultInstance; }
        }

        public scg::IList<global::transit_realtime.TripUpdate.Types.StopTimeUpdate> StopTimeUpdateList
        {
            get { return stopTimeUpdate_; }
        }

        public int StopTimeUpdateCount
        {
            get { return stopTimeUpdate_.Count; }
        }

        public bool HasTimestamp
        {
            get { return hasTimestamp; }
        }

        [global::System.CLSCompliant(false)]
        public ulong Timestamp
        {
            get { return timestamp_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasTrip) {
                    return false;
                }
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasTrip) {
                    size += pb::CodedOutputStream.ComputeMessageSize(1, Trip);
                }
                if (hasVehicle) {
                    size += pb::CodedOutputStream.ComputeMessageSize(3, Vehicle);
                }
                foreach (var element in StopTimeUpdateList) {
                    size += pb::CodedOutputStream.ComputeMessageSize(2, element);
                }
                if (hasTimestamp) {
                    size += pb::CodedOutputStream.ComputeUInt64Size(4, Timestamp);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        #region Nested types

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class StopTimeEvent : pb::ExtendableMessage<StopTimeEvent, StopTimeEvent.Builder>
            {
                public const int DelayFieldNumber = 1;
                public const int TimeFieldNumber = 2;
                public const int UncertaintyFieldNumber = 3;
                private static readonly StopTimeEvent defaultInstance = new StopTimeEvent().MakeReadOnly();

                private static readonly string[] _stopTimeEventFieldNames = new string[]
                {"delay", "time", "uncertainty"};

                private static readonly uint[] _stopTimeEventFieldTags = new uint[] {8, 16, 24};
                private int delay_;
                private bool hasDelay;
                private bool hasTime;
                private bool hasUncertainty;
                private int memoizedSerializedSize = -1;
                private long time_;
                private int uncertainty_;

                static StopTimeEvent()
                {
                    ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
                }

                private StopTimeEvent()
                {}

                public static StopTimeEvent DefaultInstance
                {
                    get { return defaultInstance; }
                }

                public override StopTimeEvent DefaultInstanceForType
                {
                    get { return DefaultInstance; }
                }

                protected override StopTimeEvent ThisMessage
                {
                    get { return this; }
                }

                public static pbd::MessageDescriptor Descriptor
                {
                    get
                    {
                        return
                            global::transit_realtime.Gtfsrealtime
                                .internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor;
                    }
                }

                protected override pb::FieldAccess.FieldAccessorTable<StopTimeEvent, StopTimeEvent.Builder>
                    InternalFieldAccessors
                {
                    get
                    {
                        return
                            global::transit_realtime.Gtfsrealtime
                                .internal__static_transit_realtime_TripUpdate_StopTimeEvent__FieldAccessorTable;
                    }
                }

                public bool HasDelay
                {
                    get { return hasDelay; }
                }

                public int Delay
                {
                    get { return delay_; }
                }

                public bool HasTime
                {
                    get { return hasTime; }
                }

                public long Time
                {
                    get { return time_; }
                }

                public bool HasUncertainty
                {
                    get { return hasUncertainty; }
                }

                public int Uncertainty
                {
                    get { return uncertainty_; }
                }

                public override bool IsInitialized
                {
                    get
                    {
                        if (!ExtensionsAreInitialized) {
                            return false;
                        }
                        return true;
                    }
                }

                public override int SerializedSize
                {
                    get
                    {
                        int size = memoizedSerializedSize;
                        if (size != -1) {
                            return size;
                        }

                        size = 0;
                        if (hasDelay) {
                            size += pb::CodedOutputStream.ComputeInt32Size(1, Delay);
                        }
                        if (hasTime) {
                            size += pb::CodedOutputStream.ComputeInt64Size(2, Time);
                        }
                        if (hasUncertainty) {
                            size += pb::CodedOutputStream.ComputeInt32Size(3, Uncertainty);
                        }
                        size += ExtensionsSerializedSize;
                        size += UnknownFields.SerializedSize;
                        memoizedSerializedSize = size;
                        return size;
                    }
                }

                public override void WriteTo(pb::ICodedOutputStream output)
                {
                    int size = SerializedSize;
                    string[] field_names = _stopTimeEventFieldNames;
                    pb::ExtendableMessage<StopTimeEvent, StopTimeEvent.Builder>.ExtensionWriter extensionWriter =
                        CreateExtensionWriter(this);
                    if (hasDelay) {
                        output.WriteInt32(1, field_names[0], Delay);
                    }
                    if (hasTime) {
                        output.WriteInt64(2, field_names[1], Time);
                    }
                    if (hasUncertainty) {
                        output.WriteInt32(3, field_names[2], Uncertainty);
                    }
                    extensionWriter.WriteUntil(2000, output);
                    UnknownFields.WriteTo(output);
                }

                public static StopTimeEvent ParseFrom(pb::ByteString data)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
                }

                public static StopTimeEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }

                public static StopTimeEvent ParseFrom(byte[] data)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
                }

                public static StopTimeEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }

                public static StopTimeEvent ParseFrom(global::System.IO.Stream input)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
                }

                public static StopTimeEvent ParseFrom(global::System.IO.Stream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }

                public static StopTimeEvent ParseDelimitedFrom(global::System.IO.Stream input)
                {
                    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
                }

                public static StopTimeEvent ParseDelimitedFrom(global::System.IO.Stream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
                }

                public static StopTimeEvent ParseFrom(pb::ICodedInputStream input)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
                }

                public static StopTimeEvent ParseFrom(pb::ICodedInputStream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }

                private StopTimeEvent MakeReadOnly()
                {
                    return this;
                }

                public static Builder CreateBuilder()
                {
                    return new Builder();
                }

                public override Builder ToBuilder()
                {
                    return CreateBuilder(this);
                }

                public override Builder CreateBuilderForType()
                {
                    return new Builder();
                }

                public static Builder CreateBuilder(StopTimeEvent prototype)
                {
                    return new Builder(prototype);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public sealed partial class Builder : pb::ExtendableBuilder<StopTimeEvent, Builder>
                {
                    private StopTimeEvent result;
                    private bool resultIsReadOnly;

                    public Builder()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                    }

                    internal Builder(StopTimeEvent cloneFrom)
                    {
                        result = cloneFrom;
                        resultIsReadOnly = true;
                    }

                    protected override Builder ThisBuilder
                    {
                        get { return this; }
                    }

                    public override bool IsInitialized
                    {
                        get { return result.IsInitialized; }
                    }

                    protected override StopTimeEvent MessageBeingBuilt
                    {
                        get { return PrepareBuilder(); }
                    }

                    public override pbd::MessageDescriptor DescriptorForType
                    {
                        get { return Descriptor; }
                    }

                    public override StopTimeEvent DefaultInstanceForType
                    {
                        get { return DefaultInstance; }
                    }

                    public bool HasDelay
                    {
                        get { return result.hasDelay; }
                    }

                    public int Delay
                    {
                        get { return result.Delay; }
                        set { SetDelay(value); }
                    }

                    public bool HasTime
                    {
                        get { return result.hasTime; }
                    }

                    public long Time
                    {
                        get { return result.Time; }
                        set { SetTime(value); }
                    }

                    public bool HasUncertainty
                    {
                        get { return result.hasUncertainty; }
                    }

                    public int Uncertainty
                    {
                        get { return result.Uncertainty; }
                        set { SetUncertainty(value); }
                    }

                    private StopTimeEvent PrepareBuilder()
                    {
                        if (resultIsReadOnly) {
                            StopTimeEvent original = result;
                            result = new StopTimeEvent();
                            resultIsReadOnly = false;
                            MergeFrom(original);
                        }
                        return result;
                    }

                    public override Builder Clear()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                        return this;
                    }

                    public override Builder Clone()
                    {
                        if (resultIsReadOnly) {
                            return new Builder(result);
                        } else {
                            return new Builder().MergeFrom(result);
                        }
                    }

                    public override StopTimeEvent BuildPartial()
                    {
                        if (resultIsReadOnly) {
                            return result;
                        }
                        resultIsReadOnly = true;
                        return result.MakeReadOnly();
                    }

                    public override Builder MergeFrom(pb::IMessage other)
                    {
                        if (other is StopTimeEvent) {
                            return MergeFrom((StopTimeEvent) other);
                        } else {
                            base.MergeFrom(other);
                            return this;
                        }
                    }

                    public override Builder MergeFrom(StopTimeEvent other)
                    {
                        if (other == DefaultInstance) {
                            return this;
                        }
                        PrepareBuilder();
                        if (other.HasDelay) {
                            Delay = other.Delay;
                        }
                        if (other.HasTime) {
                            Time = other.Time;
                        }
                        if (other.HasUncertainty) {
                            Uncertainty = other.Uncertainty;
                        }
                        this.MergeExtensionFields(other);
                        this.MergeUnknownFields(other.UnknownFields);
                        return this;
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input)
                    {
                        return MergeFrom(input, pb::ExtensionRegistry.Empty);
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input,
                        pb::ExtensionRegistry extensionRegistry)
                    {
                        PrepareBuilder();
                        pb::UnknownFieldSet.Builder unknownFields = null;
                        uint tag;
                        string field_name;
                        while (input.ReadTag(out tag, out field_name)) {
                            if (tag == 0 && field_name != null) {
                                int field_ordinal = global::System.Array.BinarySearch(_stopTimeEventFieldNames,
                                    field_name, global::System.StringComparer.Ordinal);
                                if (field_ordinal >= 0) {
                                    tag = _stopTimeEventFieldTags[field_ordinal];
                                } else {
                                    if (unknownFields == null) {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    continue;
                                }
                            }
                            switch (tag) {
                                case 0:
                                {
                                    throw pb::InvalidProtocolBufferException.InvalidTag();
                                }
                                default:
                                {
                                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                                        if (unknownFields != null) {
                                            this.UnknownFields = unknownFields.Build();
                                        }
                                        return this;
                                    }
                                    if (unknownFields == null) {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    break;
                                }
                                case 8:
                                {
                                    result.hasDelay = input.ReadInt32(ref result.delay_);
                                    break;
                                }
                                case 16:
                                {
                                    result.hasTime = input.ReadInt64(ref result.time_);
                                    break;
                                }
                                case 24:
                                {
                                    result.hasUncertainty = input.ReadInt32(ref result.uncertainty_);
                                    break;
                                }
                            }
                        }

                        if (unknownFields != null) {
                            this.UnknownFields = unknownFields.Build();
                        }
                        return this;
                    }


                    public Builder SetDelay(int value)
                    {
                        PrepareBuilder();
                        result.hasDelay = true;
                        result.delay_ = value;
                        return this;
                    }

                    public Builder ClearDelay()
                    {
                        PrepareBuilder();
                        result.hasDelay = false;
                        result.delay_ = 0;
                        return this;
                    }

                    public Builder SetTime(long value)
                    {
                        PrepareBuilder();
                        result.hasTime = true;
                        result.time_ = value;
                        return this;
                    }

                    public Builder ClearTime()
                    {
                        PrepareBuilder();
                        result.hasTime = false;
                        result.time_ = 0L;
                        return this;
                    }

                    public Builder SetUncertainty(int value)
                    {
                        PrepareBuilder();
                        result.hasUncertainty = true;
                        result.uncertainty_ = value;
                        return this;
                    }

                    public Builder ClearUncertainty()
                    {
                        PrepareBuilder();
                        result.hasUncertainty = false;
                        result.uncertainty_ = 0;
                        return this;
                    }
                }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class StopTimeUpdate : pb::ExtendableMessage<StopTimeUpdate, StopTimeUpdate.Builder>
            {
                public const int StopSequenceFieldNumber = 1;
                public const int StopIdFieldNumber = 4;
                public const int ArrivalFieldNumber = 2;
                public const int DepartureFieldNumber = 3;
                public const int ScheduleRelationshipFieldNumber = 5;
                private static readonly StopTimeUpdate defaultInstance = new StopTimeUpdate().MakeReadOnly();

                private static readonly string[] _stopTimeUpdateFieldNames = new string[]
                {"arrival", "departure", "schedule_relationship", "stop_id", "stop_sequence"};

                private static readonly uint[] _stopTimeUpdateFieldTags = new uint[] {18, 26, 40, 34, 8};
                private global::transit_realtime.TripUpdate.Types.StopTimeEvent arrival_;
                private global::transit_realtime.TripUpdate.Types.StopTimeEvent departure_;
                private bool hasArrival;
                private bool hasDeparture;
                private bool hasScheduleRelationship;
                private bool hasStopId;
                private bool hasStopSequence;
                private int memoizedSerializedSize = -1;

                private global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship
                    scheduleRelationship_ =
                        global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship.SCHEDULED;

                private string stopId_ = "";
                private uint stopSequence_;

                static StopTimeUpdate()
                {
                    ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
                }

                private StopTimeUpdate()
                {}

                public static StopTimeUpdate DefaultInstance
                {
                    get { return defaultInstance; }
                }

                public override StopTimeUpdate DefaultInstanceForType
                {
                    get { return DefaultInstance; }
                }

                protected override StopTimeUpdate ThisMessage
                {
                    get { return this; }
                }

                public static pbd::MessageDescriptor Descriptor
                {
                    get
                    {
                        return
                            global::transit_realtime.Gtfsrealtime
                                .internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor;
                    }
                }

                protected override pb::FieldAccess.FieldAccessorTable<StopTimeUpdate, StopTimeUpdate.Builder>
                    InternalFieldAccessors
                {
                    get
                    {
                        return
                            global::transit_realtime.Gtfsrealtime
                                .internal__static_transit_realtime_TripUpdate_StopTimeUpdate__FieldAccessorTable;
                    }
                }

                public bool HasStopSequence
                {
                    get { return hasStopSequence; }
                }

                [global::System.CLSCompliant(false)]
                public uint StopSequence
                {
                    get { return stopSequence_; }
                }

                public bool HasStopId
                {
                    get { return hasStopId; }
                }

                public string StopId
                {
                    get { return stopId_; }
                }

                public bool HasArrival
                {
                    get { return hasArrival; }
                }

                public global::transit_realtime.TripUpdate.Types.StopTimeEvent Arrival
                {
                    get { return arrival_ ?? global::transit_realtime.TripUpdate.Types.StopTimeEvent.DefaultInstance; }
                }

                public bool HasDeparture
                {
                    get { return hasDeparture; }
                }

                public global::transit_realtime.TripUpdate.Types.StopTimeEvent Departure
                {
                    get
                    {
                        return departure_ ?? global::transit_realtime.TripUpdate.Types.StopTimeEvent.DefaultInstance;
                    }
                }

                public bool HasScheduleRelationship
                {
                    get { return hasScheduleRelationship; }
                }

                public global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship
                    ScheduleRelationship
                {
                    get { return scheduleRelationship_; }
                }

                public override bool IsInitialized
                {
                    get
                    {
                        if (!ExtensionsAreInitialized) {
                            return false;
                        }
                        return true;
                    }
                }

                public override int SerializedSize
                {
                    get
                    {
                        int size = memoizedSerializedSize;
                        if (size != -1) {
                            return size;
                        }

                        size = 0;
                        if (hasStopSequence) {
                            size += pb::CodedOutputStream.ComputeUInt32Size(1, StopSequence);
                        }
                        if (hasStopId) {
                            size += pb::CodedOutputStream.ComputeStringSize(4, StopId);
                        }
                        if (hasArrival) {
                            size += pb::CodedOutputStream.ComputeMessageSize(2, Arrival);
                        }
                        if (hasDeparture) {
                            size += pb::CodedOutputStream.ComputeMessageSize(3, Departure);
                        }
                        if (hasScheduleRelationship) {
                            size += pb::CodedOutputStream.ComputeEnumSize(5, (int) ScheduleRelationship);
                        }
                        size += ExtensionsSerializedSize;
                        size += UnknownFields.SerializedSize;
                        memoizedSerializedSize = size;
                        return size;
                    }
                }

                #region Nested types

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public static partial class Types
                {
                    public enum ScheduleRelationship
                    {
                        SCHEDULED = 0,
                        SKIPPED = 1,
                        NO_DATA = 2,
                    }
                }

                #endregion

                public override void WriteTo(pb::ICodedOutputStream output)
                {
                    int size = SerializedSize;
                    string[] field_names = _stopTimeUpdateFieldNames;
                    pb::ExtendableMessage<StopTimeUpdate, StopTimeUpdate.Builder>.ExtensionWriter extensionWriter =
                        CreateExtensionWriter(this);
                    if (hasStopSequence) {
                        output.WriteUInt32(1, field_names[4], StopSequence);
                    }
                    if (hasArrival) {
                        output.WriteMessage(2, field_names[0], Arrival);
                    }
                    if (hasDeparture) {
                        output.WriteMessage(3, field_names[1], Departure);
                    }
                    if (hasStopId) {
                        output.WriteString(4, field_names[3], StopId);
                    }
                    if (hasScheduleRelationship) {
                        output.WriteEnum(5, field_names[2], (int) ScheduleRelationship, ScheduleRelationship);
                    }
                    extensionWriter.WriteUntil(2000, output);
                    UnknownFields.WriteTo(output);
                }

                public static StopTimeUpdate ParseFrom(pb::ByteString data)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
                }

                public static StopTimeUpdate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }

                public static StopTimeUpdate ParseFrom(byte[] data)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
                }

                public static StopTimeUpdate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }

                public static StopTimeUpdate ParseFrom(global::System.IO.Stream input)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
                }

                public static StopTimeUpdate ParseFrom(global::System.IO.Stream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }

                public static StopTimeUpdate ParseDelimitedFrom(global::System.IO.Stream input)
                {
                    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
                }

                public static StopTimeUpdate ParseDelimitedFrom(global::System.IO.Stream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
                }

                public static StopTimeUpdate ParseFrom(pb::ICodedInputStream input)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
                }

                public static StopTimeUpdate ParseFrom(pb::ICodedInputStream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }

                private StopTimeUpdate MakeReadOnly()
                {
                    return this;
                }

                public static Builder CreateBuilder()
                {
                    return new Builder();
                }

                public override Builder ToBuilder()
                {
                    return CreateBuilder(this);
                }

                public override Builder CreateBuilderForType()
                {
                    return new Builder();
                }

                public static Builder CreateBuilder(StopTimeUpdate prototype)
                {
                    return new Builder(prototype);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public sealed partial class Builder : pb::ExtendableBuilder<StopTimeUpdate, Builder>
                {
                    private StopTimeUpdate result;
                    private bool resultIsReadOnly;

                    public Builder()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                    }

                    internal Builder(StopTimeUpdate cloneFrom)
                    {
                        result = cloneFrom;
                        resultIsReadOnly = true;
                    }

                    protected override Builder ThisBuilder
                    {
                        get { return this; }
                    }

                    public override bool IsInitialized
                    {
                        get { return result.IsInitialized; }
                    }

                    protected override StopTimeUpdate MessageBeingBuilt
                    {
                        get { return PrepareBuilder(); }
                    }

                    public override pbd::MessageDescriptor DescriptorForType
                    {
                        get { return Descriptor; }
                    }

                    public override StopTimeUpdate DefaultInstanceForType
                    {
                        get { return DefaultInstance; }
                    }

                    public bool HasStopSequence
                    {
                        get { return result.hasStopSequence; }
                    }

                    [global::System.CLSCompliant(false)]
                    public uint StopSequence
                    {
                        get { return result.StopSequence; }
                        set { SetStopSequence(value); }
                    }

                    public bool HasStopId
                    {
                        get { return result.hasStopId; }
                    }

                    public string StopId
                    {
                        get { return result.StopId; }
                        set { SetStopId(value); }
                    }

                    public bool HasArrival
                    {
                        get { return result.hasArrival; }
                    }

                    public global::transit_realtime.TripUpdate.Types.StopTimeEvent Arrival
                    {
                        get { return result.Arrival; }
                        set { SetArrival(value); }
                    }

                    public bool HasDeparture
                    {
                        get { return result.hasDeparture; }
                    }

                    public global::transit_realtime.TripUpdate.Types.StopTimeEvent Departure
                    {
                        get { return result.Departure; }
                        set { SetDeparture(value); }
                    }

                    public bool HasScheduleRelationship
                    {
                        get { return result.hasScheduleRelationship; }
                    }

                    public global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship
                        ScheduleRelationship
                    {
                        get { return result.ScheduleRelationship; }
                        set { SetScheduleRelationship(value); }
                    }

                    private StopTimeUpdate PrepareBuilder()
                    {
                        if (resultIsReadOnly) {
                            StopTimeUpdate original = result;
                            result = new StopTimeUpdate();
                            resultIsReadOnly = false;
                            MergeFrom(original);
                        }
                        return result;
                    }

                    public override Builder Clear()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                        return this;
                    }

                    public override Builder Clone()
                    {
                        if (resultIsReadOnly) {
                            return new Builder(result);
                        } else {
                            return new Builder().MergeFrom(result);
                        }
                    }

                    public override StopTimeUpdate BuildPartial()
                    {
                        if (resultIsReadOnly) {
                            return result;
                        }
                        resultIsReadOnly = true;
                        return result.MakeReadOnly();
                    }

                    public override Builder MergeFrom(pb::IMessage other)
                    {
                        if (other is StopTimeUpdate) {
                            return MergeFrom((StopTimeUpdate) other);
                        } else {
                            base.MergeFrom(other);
                            return this;
                        }
                    }

                    public override Builder MergeFrom(StopTimeUpdate other)
                    {
                        if (other == DefaultInstance) {
                            return this;
                        }
                        PrepareBuilder();
                        if (other.HasStopSequence) {
                            StopSequence = other.StopSequence;
                        }
                        if (other.HasStopId) {
                            StopId = other.StopId;
                        }
                        if (other.HasArrival) {
                            MergeArrival(other.Arrival);
                        }
                        if (other.HasDeparture) {
                            MergeDeparture(other.Departure);
                        }
                        if (other.HasScheduleRelationship) {
                            ScheduleRelationship = other.ScheduleRelationship;
                        }
                        this.MergeExtensionFields(other);
                        this.MergeUnknownFields(other.UnknownFields);
                        return this;
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input)
                    {
                        return MergeFrom(input, pb::ExtensionRegistry.Empty);
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input,
                        pb::ExtensionRegistry extensionRegistry)
                    {
                        PrepareBuilder();
                        pb::UnknownFieldSet.Builder unknownFields = null;
                        uint tag;
                        string field_name;
                        while (input.ReadTag(out tag, out field_name)) {
                            if (tag == 0 && field_name != null) {
                                int field_ordinal = global::System.Array.BinarySearch(_stopTimeUpdateFieldNames,
                                    field_name, global::System.StringComparer.Ordinal);
                                if (field_ordinal >= 0) {
                                    tag = _stopTimeUpdateFieldTags[field_ordinal];
                                } else {
                                    if (unknownFields == null) {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    continue;
                                }
                            }
                            switch (tag) {
                                case 0:
                                {
                                    throw pb::InvalidProtocolBufferException.InvalidTag();
                                }
                                default:
                                {
                                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                                        if (unknownFields != null) {
                                            this.UnknownFields = unknownFields.Build();
                                        }
                                        return this;
                                    }
                                    if (unknownFields == null) {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    break;
                                }
                                case 8:
                                {
                                    result.hasStopSequence = input.ReadUInt32(ref result.stopSequence_);
                                    break;
                                }
                                case 18:
                                {
                                    global::transit_realtime.TripUpdate.Types.StopTimeEvent.Builder subBuilder =
                                        global::transit_realtime.TripUpdate.Types.StopTimeEvent.CreateBuilder();
                                    if (result.hasArrival) {
                                        subBuilder.MergeFrom(Arrival);
                                    }
                                    input.ReadMessage(subBuilder, extensionRegistry);
                                    Arrival = subBuilder.BuildPartial();
                                    break;
                                }
                                case 26:
                                {
                                    global::transit_realtime.TripUpdate.Types.StopTimeEvent.Builder subBuilder =
                                        global::transit_realtime.TripUpdate.Types.StopTimeEvent.CreateBuilder();
                                    if (result.hasDeparture) {
                                        subBuilder.MergeFrom(Departure);
                                    }
                                    input.ReadMessage(subBuilder, extensionRegistry);
                                    Departure = subBuilder.BuildPartial();
                                    break;
                                }
                                case 34:
                                {
                                    result.hasStopId = input.ReadString(ref result.stopId_);
                                    break;
                                }
                                case 40:
                                {
                                    object unknown;
                                    if (input.ReadEnum(ref result.scheduleRelationship_, out unknown)) {
                                        result.hasScheduleRelationship = true;
                                    } else if (unknown is int) {
                                        if (unknownFields == null) {
                                            unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                        }
                                        unknownFields.MergeVarintField(5, (ulong) (int) unknown);
                                    }
                                    break;
                                }
                            }
                        }

                        if (unknownFields != null) {
                            this.UnknownFields = unknownFields.Build();
                        }
                        return this;
                    }


                    [global::System.CLSCompliant(false)]
                    public Builder SetStopSequence(uint value)
                    {
                        PrepareBuilder();
                        result.hasStopSequence = true;
                        result.stopSequence_ = value;
                        return this;
                    }

                    public Builder ClearStopSequence()
                    {
                        PrepareBuilder();
                        result.hasStopSequence = false;
                        result.stopSequence_ = 0;
                        return this;
                    }

                    public Builder SetStopId(string value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasStopId = true;
                        result.stopId_ = value;
                        return this;
                    }

                    public Builder ClearStopId()
                    {
                        PrepareBuilder();
                        result.hasStopId = false;
                        result.stopId_ = "";
                        return this;
                    }

                    public Builder SetArrival(global::transit_realtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasArrival = true;
                        result.arrival_ = value;
                        return this;
                    }

                    public Builder SetArrival(
                        global::transit_realtime.TripUpdate.Types.StopTimeEvent.Builder builderForValue)
                    {
                        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                        PrepareBuilder();
                        result.hasArrival = true;
                        result.arrival_ = builderForValue.Build();
                        return this;
                    }

                    public Builder MergeArrival(global::transit_realtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        if (result.hasArrival &&
                            result.arrival_ != global::transit_realtime.TripUpdate.Types.StopTimeEvent.DefaultInstance) {
                            result.arrival_ =
                                global::transit_realtime.TripUpdate.Types.StopTimeEvent.CreateBuilder(result.arrival_)
                                    .MergeFrom(value)
                                    .BuildPartial();
                        } else {
                            result.arrival_ = value;
                        }
                        result.hasArrival = true;
                        return this;
                    }

                    public Builder ClearArrival()
                    {
                        PrepareBuilder();
                        result.hasArrival = false;
                        result.arrival_ = null;
                        return this;
                    }

                    public Builder SetDeparture(global::transit_realtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasDeparture = true;
                        result.departure_ = value;
                        return this;
                    }

                    public Builder SetDeparture(
                        global::transit_realtime.TripUpdate.Types.StopTimeEvent.Builder builderForValue)
                    {
                        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                        PrepareBuilder();
                        result.hasDeparture = true;
                        result.departure_ = builderForValue.Build();
                        return this;
                    }

                    public Builder MergeDeparture(global::transit_realtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        if (result.hasDeparture &&
                            result.departure_ != global::transit_realtime.TripUpdate.Types.StopTimeEvent.DefaultInstance) {
                            result.departure_ =
                                global::transit_realtime.TripUpdate.Types.StopTimeEvent.CreateBuilder(result.departure_)
                                    .MergeFrom(value)
                                    .BuildPartial();
                        } else {
                            result.departure_ = value;
                        }
                        result.hasDeparture = true;
                        return this;
                    }

                    public Builder ClearDeparture()
                    {
                        PrepareBuilder();
                        result.hasDeparture = false;
                        result.departure_ = null;
                        return this;
                    }

                    public Builder SetScheduleRelationship(
                        global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship value)
                    {
                        PrepareBuilder();
                        result.hasScheduleRelationship = true;
                        result.scheduleRelationship_ = value;
                        return this;
                    }

                    public Builder ClearScheduleRelationship()
                    {
                        PrepareBuilder();
                        result.hasScheduleRelationship = false;
                        result.scheduleRelationship_ =
                            global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship
                                .SCHEDULED;
                        return this;
                    }
                }
            }
        }

        #endregion

        public global::transit_realtime.TripUpdate.Types.StopTimeUpdate GetStopTimeUpdate(int index)
        {
            return stopTimeUpdate_[index];
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _tripUpdateFieldNames;
            pb::ExtendableMessage<TripUpdate, TripUpdate.Builder>.ExtensionWriter extensionWriter =
                CreateExtensionWriter(this);
            if (hasTrip) {
                output.WriteMessage(1, field_names[2], Trip);
            }
            if (stopTimeUpdate_.Count > 0) {
                output.WriteMessageArray(2, field_names[0], stopTimeUpdate_);
            }
            if (hasVehicle) {
                output.WriteMessage(3, field_names[3], Vehicle);
            }
            if (hasTimestamp) {
                output.WriteUInt64(4, field_names[1], Timestamp);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static TripUpdate ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TripUpdate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TripUpdate ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TripUpdate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TripUpdate ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TripUpdate ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static TripUpdate ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static TripUpdate ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static TripUpdate ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TripUpdate ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private TripUpdate MakeReadOnly()
        {
            stopTimeUpdate_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(TripUpdate prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<TripUpdate, Builder>
        {
            private TripUpdate result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(TripUpdate cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TripUpdate MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override TripUpdate DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasTrip
            {
                get { return result.hasTrip; }
            }

            public global::transit_realtime.TripDescriptor Trip
            {
                get { return result.Trip; }
                set { SetTrip(value); }
            }

            public bool HasVehicle
            {
                get { return result.hasVehicle; }
            }

            public global::transit_realtime.VehicleDescriptor Vehicle
            {
                get { return result.Vehicle; }
                set { SetVehicle(value); }
            }

            public pbc::IPopsicleList<global::transit_realtime.TripUpdate.Types.StopTimeUpdate> StopTimeUpdateList
            {
                get { return PrepareBuilder().stopTimeUpdate_; }
            }

            public int StopTimeUpdateCount
            {
                get { return result.StopTimeUpdateCount; }
            }

            public bool HasTimestamp
            {
                get { return result.hasTimestamp; }
            }

            [global::System.CLSCompliant(false)]
            public ulong Timestamp
            {
                get { return result.Timestamp; }
                set { SetTimestamp(value); }
            }

            private TripUpdate PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    TripUpdate original = result;
                    result = new TripUpdate();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override TripUpdate BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TripUpdate) {
                    return MergeFrom((TripUpdate) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TripUpdate other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasTrip) {
                    MergeTrip(other.Trip);
                }
                if (other.HasVehicle) {
                    MergeVehicle(other.Vehicle);
                }
                if (other.stopTimeUpdate_.Count != 0) {
                    result.stopTimeUpdate_.Add(other.stopTimeUpdate_);
                }
                if (other.HasTimestamp) {
                    Timestamp = other.Timestamp;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_tripUpdateFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _tripUpdateFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            global::transit_realtime.TripDescriptor.Builder subBuilder =
                                global::transit_realtime.TripDescriptor.CreateBuilder();
                            if (result.hasTrip) {
                                subBuilder.MergeFrom(Trip);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Trip = subBuilder.BuildPartial();
                            break;
                        }
                        case 18:
                        {
                            input.ReadMessageArray(tag, field_name, result.stopTimeUpdate_,
                                global::transit_realtime.TripUpdate.Types.StopTimeUpdate.DefaultInstance,
                                extensionRegistry);
                            break;
                        }
                        case 26:
                        {
                            global::transit_realtime.VehicleDescriptor.Builder subBuilder =
                                global::transit_realtime.VehicleDescriptor.CreateBuilder();
                            if (result.hasVehicle) {
                                subBuilder.MergeFrom(Vehicle);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Vehicle = subBuilder.BuildPartial();
                            break;
                        }
                        case 32:
                        {
                            result.hasTimestamp = input.ReadUInt64(ref result.timestamp_);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetTrip(global::transit_realtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = value;
                return this;
            }

            public Builder SetTrip(global::transit_realtime.TripDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = builderForValue.Build();
                return this;
            }

            public Builder MergeTrip(global::transit_realtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTrip && result.trip_ != global::transit_realtime.TripDescriptor.DefaultInstance) {
                    result.trip_ =
                        global::transit_realtime.TripDescriptor.CreateBuilder(result.trip_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.trip_ = value;
                }
                result.hasTrip = true;
                return this;
            }

            public Builder ClearTrip()
            {
                PrepareBuilder();
                result.hasTrip = false;
                result.trip_ = null;
                return this;
            }

            public Builder SetVehicle(global::transit_realtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = value;
                return this;
            }

            public Builder SetVehicle(global::transit_realtime.VehicleDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = builderForValue.Build();
                return this;
            }

            public Builder MergeVehicle(global::transit_realtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasVehicle && result.vehicle_ != global::transit_realtime.VehicleDescriptor.DefaultInstance) {
                    result.vehicle_ =
                        global::transit_realtime.VehicleDescriptor.CreateBuilder(result.vehicle_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.vehicle_ = value;
                }
                result.hasVehicle = true;
                return this;
            }

            public Builder ClearVehicle()
            {
                PrepareBuilder();
                result.hasVehicle = false;
                result.vehicle_ = null;
                return this;
            }

            public global::transit_realtime.TripUpdate.Types.StopTimeUpdate GetStopTimeUpdate(int index)
            {
                return result.GetStopTimeUpdate(index);
            }

            public Builder SetStopTimeUpdate(int index, global::transit_realtime.TripUpdate.Types.StopTimeUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.stopTimeUpdate_[index] = value;
                return this;
            }

            public Builder SetStopTimeUpdate(int index,
                global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.stopTimeUpdate_[index] = builderForValue.Build();
                return this;
            }

            public Builder AddStopTimeUpdate(global::transit_realtime.TripUpdate.Types.StopTimeUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.stopTimeUpdate_.Add(value);
                return this;
            }

            public Builder AddStopTimeUpdate(
                global::transit_realtime.TripUpdate.Types.StopTimeUpdate.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.stopTimeUpdate_.Add(builderForValue.Build());
                return this;
            }

            public Builder AddRangeStopTimeUpdate(
                scg::IEnumerable<global::transit_realtime.TripUpdate.Types.StopTimeUpdate> values)
            {
                PrepareBuilder();
                result.stopTimeUpdate_.Add(values);
                return this;
            }

            public Builder ClearStopTimeUpdate()
            {
                PrepareBuilder();
                result.stopTimeUpdate_.Clear();
                return this;
            }

            [global::System.CLSCompliant(false)]
            public Builder SetTimestamp(ulong value)
            {
                PrepareBuilder();
                result.hasTimestamp = true;
                result.timestamp_ = value;
                return this;
            }

            public Builder ClearTimestamp()
            {
                PrepareBuilder();
                result.hasTimestamp = false;
                result.timestamp_ = 0UL;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class VehiclePosition : pb::ExtendableMessage<VehiclePosition, VehiclePosition.Builder>
    {
        public const int TripFieldNumber = 1;
        public const int VehicleFieldNumber = 8;
        public const int PositionFieldNumber = 2;
        public const int CurrentStopSequenceFieldNumber = 3;
        public const int StopIdFieldNumber = 7;
        public const int CurrentStatusFieldNumber = 4;
        public const int TimestampFieldNumber = 5;
        public const int CongestionLevelFieldNumber = 6;
        private static readonly VehiclePosition defaultInstance = new VehiclePosition().MakeReadOnly();

        private static readonly string[] _vehiclePositionFieldNames = new string[]
        {
            "congestion_level", "current_status", "current_stop_sequence", "position", "stop_id", "timestamp", "trip",
            "vehicle"
        };

        private static readonly uint[] _vehiclePositionFieldTags = new uint[] {48, 32, 24, 18, 58, 40, 10, 66};

        private global::transit_realtime.VehiclePosition.Types.CongestionLevel congestionLevel_ =
            global::transit_realtime.VehiclePosition.Types.CongestionLevel.UNKNOWN_CONGESTION_LEVEL;

        private global::transit_realtime.VehiclePosition.Types.VehicleStopStatus currentStatus_ =
            global::transit_realtime.VehiclePosition.Types.VehicleStopStatus.IN_TRANSIT_TO;

        private uint currentStopSequence_;
        private bool hasCongestionLevel;
        private bool hasCurrentStatus;
        private bool hasCurrentStopSequence;
        private bool hasPosition;
        private bool hasStopId;
        private bool hasTimestamp;
        private bool hasTrip;
        private bool hasVehicle;
        private int memoizedSerializedSize = -1;
        private global::transit_realtime.Position position_;
        private string stopId_ = "";
        private ulong timestamp_;
        private global::transit_realtime.TripDescriptor trip_;
        private global::transit_realtime.VehicleDescriptor vehicle_;

        static VehiclePosition()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private VehiclePosition()
        {}

        public static VehiclePosition DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override VehiclePosition DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override VehiclePosition ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_VehiclePosition__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<VehiclePosition, VehiclePosition.Builder>
            InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_VehiclePosition__FieldAccessorTable;
            }
        }

        public bool HasTrip
        {
            get { return hasTrip; }
        }

        public global::transit_realtime.TripDescriptor Trip
        {
            get { return trip_ ?? global::transit_realtime.TripDescriptor.DefaultInstance; }
        }

        public bool HasVehicle
        {
            get { return hasVehicle; }
        }

        public global::transit_realtime.VehicleDescriptor Vehicle
        {
            get { return vehicle_ ?? global::transit_realtime.VehicleDescriptor.DefaultInstance; }
        }

        public bool HasPosition
        {
            get { return hasPosition; }
        }

        public global::transit_realtime.Position Position
        {
            get { return position_ ?? global::transit_realtime.Position.DefaultInstance; }
        }

        public bool HasCurrentStopSequence
        {
            get { return hasCurrentStopSequence; }
        }

        [global::System.CLSCompliant(false)]
        public uint CurrentStopSequence
        {
            get { return currentStopSequence_; }
        }

        public bool HasStopId
        {
            get { return hasStopId; }
        }

        public string StopId
        {
            get { return stopId_; }
        }

        public bool HasCurrentStatus
        {
            get { return hasCurrentStatus; }
        }

        public global::transit_realtime.VehiclePosition.Types.VehicleStopStatus CurrentStatus
        {
            get { return currentStatus_; }
        }

        public bool HasTimestamp
        {
            get { return hasTimestamp; }
        }

        [global::System.CLSCompliant(false)]
        public ulong Timestamp
        {
            get { return timestamp_; }
        }

        public bool HasCongestionLevel
        {
            get { return hasCongestionLevel; }
        }

        public global::transit_realtime.VehiclePosition.Types.CongestionLevel CongestionLevel
        {
            get { return congestionLevel_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (HasPosition) {
                    if (!Position.IsInitialized) {
                        return false;
                    }
                }
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasTrip) {
                    size += pb::CodedOutputStream.ComputeMessageSize(1, Trip);
                }
                if (hasVehicle) {
                    size += pb::CodedOutputStream.ComputeMessageSize(8, Vehicle);
                }
                if (hasPosition) {
                    size += pb::CodedOutputStream.ComputeMessageSize(2, Position);
                }
                if (hasCurrentStopSequence) {
                    size += pb::CodedOutputStream.ComputeUInt32Size(3, CurrentStopSequence);
                }
                if (hasStopId) {
                    size += pb::CodedOutputStream.ComputeStringSize(7, StopId);
                }
                if (hasCurrentStatus) {
                    size += pb::CodedOutputStream.ComputeEnumSize(4, (int) CurrentStatus);
                }
                if (hasTimestamp) {
                    size += pb::CodedOutputStream.ComputeUInt64Size(5, Timestamp);
                }
                if (hasCongestionLevel) {
                    size += pb::CodedOutputStream.ComputeEnumSize(6, (int) CongestionLevel);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        #region Nested types

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum CongestionLevel
            {
                UNKNOWN_CONGESTION_LEVEL = 0,
                RUNNING_SMOOTHLY = 1,
                STOP_AND_GO = 2,
                CONGESTION = 3,
                SEVERE_CONGESTION = 4,
            }

            public enum VehicleStopStatus
            {
                INCOMING_AT = 0,
                STOPPED_AT = 1,
                IN_TRANSIT_TO = 2,
            }
        }

        #endregion

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _vehiclePositionFieldNames;
            pb::ExtendableMessage<VehiclePosition, VehiclePosition.Builder>.ExtensionWriter extensionWriter =
                CreateExtensionWriter(this);
            if (hasTrip) {
                output.WriteMessage(1, field_names[6], Trip);
            }
            if (hasPosition) {
                output.WriteMessage(2, field_names[3], Position);
            }
            if (hasCurrentStopSequence) {
                output.WriteUInt32(3, field_names[2], CurrentStopSequence);
            }
            if (hasCurrentStatus) {
                output.WriteEnum(4, field_names[1], (int) CurrentStatus, CurrentStatus);
            }
            if (hasTimestamp) {
                output.WriteUInt64(5, field_names[5], Timestamp);
            }
            if (hasCongestionLevel) {
                output.WriteEnum(6, field_names[0], (int) CongestionLevel, CongestionLevel);
            }
            if (hasStopId) {
                output.WriteString(7, field_names[4], StopId);
            }
            if (hasVehicle) {
                output.WriteMessage(8, field_names[7], Vehicle);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static VehiclePosition ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static VehiclePosition ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static VehiclePosition ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static VehiclePosition ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static VehiclePosition ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static VehiclePosition ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static VehiclePosition ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static VehiclePosition ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static VehiclePosition ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static VehiclePosition ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private VehiclePosition MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(VehiclePosition prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<VehiclePosition, Builder>
        {
            private VehiclePosition result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(VehiclePosition cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override VehiclePosition MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override VehiclePosition DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasTrip
            {
                get { return result.hasTrip; }
            }

            public global::transit_realtime.TripDescriptor Trip
            {
                get { return result.Trip; }
                set { SetTrip(value); }
            }

            public bool HasVehicle
            {
                get { return result.hasVehicle; }
            }

            public global::transit_realtime.VehicleDescriptor Vehicle
            {
                get { return result.Vehicle; }
                set { SetVehicle(value); }
            }

            public bool HasPosition
            {
                get { return result.hasPosition; }
            }

            public global::transit_realtime.Position Position
            {
                get { return result.Position; }
                set { SetPosition(value); }
            }

            public bool HasCurrentStopSequence
            {
                get { return result.hasCurrentStopSequence; }
            }

            [global::System.CLSCompliant(false)]
            public uint CurrentStopSequence
            {
                get { return result.CurrentStopSequence; }
                set { SetCurrentStopSequence(value); }
            }

            public bool HasStopId
            {
                get { return result.hasStopId; }
            }

            public string StopId
            {
                get { return result.StopId; }
                set { SetStopId(value); }
            }

            public bool HasCurrentStatus
            {
                get { return result.hasCurrentStatus; }
            }

            public global::transit_realtime.VehiclePosition.Types.VehicleStopStatus CurrentStatus
            {
                get { return result.CurrentStatus; }
                set { SetCurrentStatus(value); }
            }

            public bool HasTimestamp
            {
                get { return result.hasTimestamp; }
            }

            [global::System.CLSCompliant(false)]
            public ulong Timestamp
            {
                get { return result.Timestamp; }
                set { SetTimestamp(value); }
            }

            public bool HasCongestionLevel
            {
                get { return result.hasCongestionLevel; }
            }

            public global::transit_realtime.VehiclePosition.Types.CongestionLevel CongestionLevel
            {
                get { return result.CongestionLevel; }
                set { SetCongestionLevel(value); }
            }

            private VehiclePosition PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    VehiclePosition original = result;
                    result = new VehiclePosition();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override VehiclePosition BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is VehiclePosition) {
                    return MergeFrom((VehiclePosition) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(VehiclePosition other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasTrip) {
                    MergeTrip(other.Trip);
                }
                if (other.HasVehicle) {
                    MergeVehicle(other.Vehicle);
                }
                if (other.HasPosition) {
                    MergePosition(other.Position);
                }
                if (other.HasCurrentStopSequence) {
                    CurrentStopSequence = other.CurrentStopSequence;
                }
                if (other.HasStopId) {
                    StopId = other.StopId;
                }
                if (other.HasCurrentStatus) {
                    CurrentStatus = other.CurrentStatus;
                }
                if (other.HasTimestamp) {
                    Timestamp = other.Timestamp;
                }
                if (other.HasCongestionLevel) {
                    CongestionLevel = other.CongestionLevel;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_vehiclePositionFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _vehiclePositionFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            global::transit_realtime.TripDescriptor.Builder subBuilder =
                                global::transit_realtime.TripDescriptor.CreateBuilder();
                            if (result.hasTrip) {
                                subBuilder.MergeFrom(Trip);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Trip = subBuilder.BuildPartial();
                            break;
                        }
                        case 18:
                        {
                            global::transit_realtime.Position.Builder subBuilder =
                                global::transit_realtime.Position.CreateBuilder();
                            if (result.hasPosition) {
                                subBuilder.MergeFrom(Position);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Position = subBuilder.BuildPartial();
                            break;
                        }
                        case 24:
                        {
                            result.hasCurrentStopSequence = input.ReadUInt32(ref result.currentStopSequence_);
                            break;
                        }
                        case 32:
                        {
                            object unknown;
                            if (input.ReadEnum(ref result.currentStatus_, out unknown)) {
                                result.hasCurrentStatus = true;
                            } else if (unknown is int) {
                                if (unknownFields == null) {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                unknownFields.MergeVarintField(4, (ulong) (int) unknown);
                            }
                            break;
                        }
                        case 40:
                        {
                            result.hasTimestamp = input.ReadUInt64(ref result.timestamp_);
                            break;
                        }
                        case 48:
                        {
                            object unknown;
                            if (input.ReadEnum(ref result.congestionLevel_, out unknown)) {
                                result.hasCongestionLevel = true;
                            } else if (unknown is int) {
                                if (unknownFields == null) {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                unknownFields.MergeVarintField(6, (ulong) (int) unknown);
                            }
                            break;
                        }
                        case 58:
                        {
                            result.hasStopId = input.ReadString(ref result.stopId_);
                            break;
                        }
                        case 66:
                        {
                            global::transit_realtime.VehicleDescriptor.Builder subBuilder =
                                global::transit_realtime.VehicleDescriptor.CreateBuilder();
                            if (result.hasVehicle) {
                                subBuilder.MergeFrom(Vehicle);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Vehicle = subBuilder.BuildPartial();
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetTrip(global::transit_realtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = value;
                return this;
            }

            public Builder SetTrip(global::transit_realtime.TripDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = builderForValue.Build();
                return this;
            }

            public Builder MergeTrip(global::transit_realtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTrip && result.trip_ != global::transit_realtime.TripDescriptor.DefaultInstance) {
                    result.trip_ =
                        global::transit_realtime.TripDescriptor.CreateBuilder(result.trip_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.trip_ = value;
                }
                result.hasTrip = true;
                return this;
            }

            public Builder ClearTrip()
            {
                PrepareBuilder();
                result.hasTrip = false;
                result.trip_ = null;
                return this;
            }

            public Builder SetVehicle(global::transit_realtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = value;
                return this;
            }

            public Builder SetVehicle(global::transit_realtime.VehicleDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = builderForValue.Build();
                return this;
            }

            public Builder MergeVehicle(global::transit_realtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasVehicle && result.vehicle_ != global::transit_realtime.VehicleDescriptor.DefaultInstance) {
                    result.vehicle_ =
                        global::transit_realtime.VehicleDescriptor.CreateBuilder(result.vehicle_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.vehicle_ = value;
                }
                result.hasVehicle = true;
                return this;
            }

            public Builder ClearVehicle()
            {
                PrepareBuilder();
                result.hasVehicle = false;
                result.vehicle_ = null;
                return this;
            }

            public Builder SetPosition(global::transit_realtime.Position value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasPosition = true;
                result.position_ = value;
                return this;
            }

            public Builder SetPosition(global::transit_realtime.Position.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasPosition = true;
                result.position_ = builderForValue.Build();
                return this;
            }

            public Builder MergePosition(global::transit_realtime.Position value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasPosition && result.position_ != global::transit_realtime.Position.DefaultInstance) {
                    result.position_ =
                        global::transit_realtime.Position.CreateBuilder(result.position_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.position_ = value;
                }
                result.hasPosition = true;
                return this;
            }

            public Builder ClearPosition()
            {
                PrepareBuilder();
                result.hasPosition = false;
                result.position_ = null;
                return this;
            }

            [global::System.CLSCompliant(false)]
            public Builder SetCurrentStopSequence(uint value)
            {
                PrepareBuilder();
                result.hasCurrentStopSequence = true;
                result.currentStopSequence_ = value;
                return this;
            }

            public Builder ClearCurrentStopSequence()
            {
                PrepareBuilder();
                result.hasCurrentStopSequence = false;
                result.currentStopSequence_ = 0;
                return this;
            }

            public Builder SetStopId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStopId = true;
                result.stopId_ = value;
                return this;
            }

            public Builder ClearStopId()
            {
                PrepareBuilder();
                result.hasStopId = false;
                result.stopId_ = "";
                return this;
            }

            public Builder SetCurrentStatus(global::transit_realtime.VehiclePosition.Types.VehicleStopStatus value)
            {
                PrepareBuilder();
                result.hasCurrentStatus = true;
                result.currentStatus_ = value;
                return this;
            }

            public Builder ClearCurrentStatus()
            {
                PrepareBuilder();
                result.hasCurrentStatus = false;
                result.currentStatus_ = global::transit_realtime.VehiclePosition.Types.VehicleStopStatus.IN_TRANSIT_TO;
                return this;
            }

            [global::System.CLSCompliant(false)]
            public Builder SetTimestamp(ulong value)
            {
                PrepareBuilder();
                result.hasTimestamp = true;
                result.timestamp_ = value;
                return this;
            }

            public Builder ClearTimestamp()
            {
                PrepareBuilder();
                result.hasTimestamp = false;
                result.timestamp_ = 0UL;
                return this;
            }

            public Builder SetCongestionLevel(global::transit_realtime.VehiclePosition.Types.CongestionLevel value)
            {
                PrepareBuilder();
                result.hasCongestionLevel = true;
                result.congestionLevel_ = value;
                return this;
            }

            public Builder ClearCongestionLevel()
            {
                PrepareBuilder();
                result.hasCongestionLevel = false;
                result.congestionLevel_ =
                    global::transit_realtime.VehiclePosition.Types.CongestionLevel.UNKNOWN_CONGESTION_LEVEL;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Alert : pb::ExtendableMessage<Alert, Alert.Builder>
    {
        public const int ActivePeriodFieldNumber = 1;
        public const int InformedEntityFieldNumber = 5;
        public const int CauseFieldNumber = 6;
        public const int EffectFieldNumber = 7;
        public const int UrlFieldNumber = 8;
        public const int HeaderTextFieldNumber = 10;
        public const int DescriptionTextFieldNumber = 11;
        private static readonly Alert defaultInstance = new Alert().MakeReadOnly();

        private static readonly string[] _alertFieldNames = new string[]
        {"active_period", "cause", "description_text", "effect", "header_text", "informed_entity", "url"};

        private static readonly uint[] _alertFieldTags = new uint[] {10, 48, 90, 56, 82, 42, 66};

        private pbc::PopsicleList<global::transit_realtime.TimeRange> activePeriod_ =
            new pbc::PopsicleList<global::transit_realtime.TimeRange>();

        private global::transit_realtime.Alert.Types.Cause cause_ =
            global::transit_realtime.Alert.Types.Cause.UNKNOWN_CAUSE;

        private global::transit_realtime.TranslatedString descriptionText_;

        private global::transit_realtime.Alert.Types.Effect effect_ =
            global::transit_realtime.Alert.Types.Effect.UNKNOWN_EFFECT;

        private bool hasCause;
        private bool hasDescriptionText;
        private bool hasEffect;
        private bool hasHeaderText;
        private bool hasUrl;
        private global::transit_realtime.TranslatedString headerText_;

        private pbc::PopsicleList<global::transit_realtime.EntitySelector> informedEntity_ =
            new pbc::PopsicleList<global::transit_realtime.EntitySelector>();

        private int memoizedSerializedSize = -1;
        private global::transit_realtime.TranslatedString url_;

        static Alert()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private Alert()
        {}

        public static Alert DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override Alert DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override Alert ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_Alert__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<Alert, Alert.Builder> InternalFieldAccessors
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_Alert__FieldAccessorTable;
            }
        }

        public scg::IList<global::transit_realtime.TimeRange> ActivePeriodList
        {
            get { return activePeriod_; }
        }

        public int ActivePeriodCount
        {
            get { return activePeriod_.Count; }
        }

        public scg::IList<global::transit_realtime.EntitySelector> InformedEntityList
        {
            get { return informedEntity_; }
        }

        public int InformedEntityCount
        {
            get { return informedEntity_.Count; }
        }

        public bool HasCause
        {
            get { return hasCause; }
        }

        public global::transit_realtime.Alert.Types.Cause Cause
        {
            get { return cause_; }
        }

        public bool HasEffect
        {
            get { return hasEffect; }
        }

        public global::transit_realtime.Alert.Types.Effect Effect
        {
            get { return effect_; }
        }

        public bool HasUrl
        {
            get { return hasUrl; }
        }

        public global::transit_realtime.TranslatedString Url
        {
            get { return url_ ?? global::transit_realtime.TranslatedString.DefaultInstance; }
        }

        public bool HasHeaderText
        {
            get { return hasHeaderText; }
        }

        public global::transit_realtime.TranslatedString HeaderText
        {
            get { return headerText_ ?? global::transit_realtime.TranslatedString.DefaultInstance; }
        }

        public bool HasDescriptionText
        {
            get { return hasDescriptionText; }
        }

        public global::transit_realtime.TranslatedString DescriptionText
        {
            get { return descriptionText_ ?? global::transit_realtime.TranslatedString.DefaultInstance; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (HasUrl) {
                    if (!Url.IsInitialized) {
                        return false;
                    }
                }
                if (HasHeaderText) {
                    if (!HeaderText.IsInitialized) {
                        return false;
                    }
                }
                if (HasDescriptionText) {
                    if (!DescriptionText.IsInitialized) {
                        return false;
                    }
                }
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                foreach (var element in ActivePeriodList) {
                    size += pb::CodedOutputStream.ComputeMessageSize(1, element);
                }
                foreach (var element in InformedEntityList) {
                    size += pb::CodedOutputStream.ComputeMessageSize(5, element);
                }
                if (hasCause) {
                    size += pb::CodedOutputStream.ComputeEnumSize(6, (int) Cause);
                }
                if (hasEffect) {
                    size += pb::CodedOutputStream.ComputeEnumSize(7, (int) Effect);
                }
                if (hasUrl) {
                    size += pb::CodedOutputStream.ComputeMessageSize(8, Url);
                }
                if (hasHeaderText) {
                    size += pb::CodedOutputStream.ComputeMessageSize(10, HeaderText);
                }
                if (hasDescriptionText) {
                    size += pb::CodedOutputStream.ComputeMessageSize(11, DescriptionText);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        #region Nested types

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum Cause
            {
                UNKNOWN_CAUSE = 1,
                OTHER_CAUSE = 2,
                TECHNICAL_PROBLEM = 3,
                STRIKE = 4,
                DEMONSTRATION = 5,
                ACCIDENT = 6,
                HOLIDAY = 7,
                WEATHER = 8,
                MAINTENANCE = 9,
                CONSTRUCTION = 10,
                POLICE_ACTIVITY = 11,
                MEDICAL_EMERGENCY = 12,
            }

            public enum Effect
            {
                NO_SERVICE = 1,
                REDUCED_SERVICE = 2,
                SIGNIFICANT_DELAYS = 3,
                DETOUR = 4,
                ADDITIONAL_SERVICE = 5,
                MODIFIED_SERVICE = 6,
                OTHER_EFFECT = 7,
                UNKNOWN_EFFECT = 8,
                STOP_MOVED = 9,
            }
        }

        #endregion

        public global::transit_realtime.TimeRange GetActivePeriod(int index)
        {
            return activePeriod_[index];
        }

        public global::transit_realtime.EntitySelector GetInformedEntity(int index)
        {
            return informedEntity_[index];
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _alertFieldNames;
            pb::ExtendableMessage<Alert, Alert.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (activePeriod_.Count > 0) {
                output.WriteMessageArray(1, field_names[0], activePeriod_);
            }
            if (informedEntity_.Count > 0) {
                output.WriteMessageArray(5, field_names[5], informedEntity_);
            }
            if (hasCause) {
                output.WriteEnum(6, field_names[1], (int) Cause, Cause);
            }
            if (hasEffect) {
                output.WriteEnum(7, field_names[3], (int) Effect, Effect);
            }
            if (hasUrl) {
                output.WriteMessage(8, field_names[6], Url);
            }
            if (hasHeaderText) {
                output.WriteMessage(10, field_names[4], HeaderText);
            }
            if (hasDescriptionText) {
                output.WriteMessage(11, field_names[2], DescriptionText);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static Alert ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static Alert ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static Alert ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static Alert ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static Alert ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static Alert ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static Alert ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static Alert ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static Alert ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static Alert ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private Alert MakeReadOnly()
        {
            activePeriod_.MakeReadOnly();
            informedEntity_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(Alert prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<Alert, Builder>
        {
            private Alert result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(Alert cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override Alert MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override Alert DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public pbc::IPopsicleList<global::transit_realtime.TimeRange> ActivePeriodList
            {
                get { return PrepareBuilder().activePeriod_; }
            }

            public int ActivePeriodCount
            {
                get { return result.ActivePeriodCount; }
            }

            public pbc::IPopsicleList<global::transit_realtime.EntitySelector> InformedEntityList
            {
                get { return PrepareBuilder().informedEntity_; }
            }

            public int InformedEntityCount
            {
                get { return result.InformedEntityCount; }
            }

            public bool HasCause
            {
                get { return result.hasCause; }
            }

            public global::transit_realtime.Alert.Types.Cause Cause
            {
                get { return result.Cause; }
                set { SetCause(value); }
            }

            public bool HasEffect
            {
                get { return result.hasEffect; }
            }

            public global::transit_realtime.Alert.Types.Effect Effect
            {
                get { return result.Effect; }
                set { SetEffect(value); }
            }

            public bool HasUrl
            {
                get { return result.hasUrl; }
            }

            public global::transit_realtime.TranslatedString Url
            {
                get { return result.Url; }
                set { SetUrl(value); }
            }

            public bool HasHeaderText
            {
                get { return result.hasHeaderText; }
            }

            public global::transit_realtime.TranslatedString HeaderText
            {
                get { return result.HeaderText; }
                set { SetHeaderText(value); }
            }

            public bool HasDescriptionText
            {
                get { return result.hasDescriptionText; }
            }

            public global::transit_realtime.TranslatedString DescriptionText
            {
                get { return result.DescriptionText; }
                set { SetDescriptionText(value); }
            }

            private Alert PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    Alert original = result;
                    result = new Alert();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override Alert BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is Alert) {
                    return MergeFrom((Alert) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(Alert other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.activePeriod_.Count != 0) {
                    result.activePeriod_.Add(other.activePeriod_);
                }
                if (other.informedEntity_.Count != 0) {
                    result.informedEntity_.Add(other.informedEntity_);
                }
                if (other.HasCause) {
                    Cause = other.Cause;
                }
                if (other.HasEffect) {
                    Effect = other.Effect;
                }
                if (other.HasUrl) {
                    MergeUrl(other.Url);
                }
                if (other.HasHeaderText) {
                    MergeHeaderText(other.HeaderText);
                }
                if (other.HasDescriptionText) {
                    MergeDescriptionText(other.DescriptionText);
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_alertFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _alertFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            input.ReadMessageArray(tag, field_name, result.activePeriod_,
                                global::transit_realtime.TimeRange.DefaultInstance, extensionRegistry);
                            break;
                        }
                        case 42:
                        {
                            input.ReadMessageArray(tag, field_name, result.informedEntity_,
                                global::transit_realtime.EntitySelector.DefaultInstance, extensionRegistry);
                            break;
                        }
                        case 48:
                        {
                            object unknown;
                            if (input.ReadEnum(ref result.cause_, out unknown)) {
                                result.hasCause = true;
                            } else if (unknown is int) {
                                if (unknownFields == null) {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                unknownFields.MergeVarintField(6, (ulong) (int) unknown);
                            }
                            break;
                        }
                        case 56:
                        {
                            object unknown;
                            if (input.ReadEnum(ref result.effect_, out unknown)) {
                                result.hasEffect = true;
                            } else if (unknown is int) {
                                if (unknownFields == null) {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                unknownFields.MergeVarintField(7, (ulong) (int) unknown);
                            }
                            break;
                        }
                        case 66:
                        {
                            global::transit_realtime.TranslatedString.Builder subBuilder =
                                global::transit_realtime.TranslatedString.CreateBuilder();
                            if (result.hasUrl) {
                                subBuilder.MergeFrom(Url);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Url = subBuilder.BuildPartial();
                            break;
                        }
                        case 82:
                        {
                            global::transit_realtime.TranslatedString.Builder subBuilder =
                                global::transit_realtime.TranslatedString.CreateBuilder();
                            if (result.hasHeaderText) {
                                subBuilder.MergeFrom(HeaderText);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            HeaderText = subBuilder.BuildPartial();
                            break;
                        }
                        case 90:
                        {
                            global::transit_realtime.TranslatedString.Builder subBuilder =
                                global::transit_realtime.TranslatedString.CreateBuilder();
                            if (result.hasDescriptionText) {
                                subBuilder.MergeFrom(DescriptionText);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            DescriptionText = subBuilder.BuildPartial();
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public global::transit_realtime.TimeRange GetActivePeriod(int index)
            {
                return result.GetActivePeriod(index);
            }

            public Builder SetActivePeriod(int index, global::transit_realtime.TimeRange value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.activePeriod_[index] = value;
                return this;
            }

            public Builder SetActivePeriod(int index, global::transit_realtime.TimeRange.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.activePeriod_[index] = builderForValue.Build();
                return this;
            }

            public Builder AddActivePeriod(global::transit_realtime.TimeRange value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.activePeriod_.Add(value);
                return this;
            }

            public Builder AddActivePeriod(global::transit_realtime.TimeRange.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.activePeriod_.Add(builderForValue.Build());
                return this;
            }

            public Builder AddRangeActivePeriod(scg::IEnumerable<global::transit_realtime.TimeRange> values)
            {
                PrepareBuilder();
                result.activePeriod_.Add(values);
                return this;
            }

            public Builder ClearActivePeriod()
            {
                PrepareBuilder();
                result.activePeriod_.Clear();
                return this;
            }

            public global::transit_realtime.EntitySelector GetInformedEntity(int index)
            {
                return result.GetInformedEntity(index);
            }

            public Builder SetInformedEntity(int index, global::transit_realtime.EntitySelector value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.informedEntity_[index] = value;
                return this;
            }

            public Builder SetInformedEntity(int index, global::transit_realtime.EntitySelector.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.informedEntity_[index] = builderForValue.Build();
                return this;
            }

            public Builder AddInformedEntity(global::transit_realtime.EntitySelector value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.informedEntity_.Add(value);
                return this;
            }

            public Builder AddInformedEntity(global::transit_realtime.EntitySelector.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.informedEntity_.Add(builderForValue.Build());
                return this;
            }

            public Builder AddRangeInformedEntity(scg::IEnumerable<global::transit_realtime.EntitySelector> values)
            {
                PrepareBuilder();
                result.informedEntity_.Add(values);
                return this;
            }

            public Builder ClearInformedEntity()
            {
                PrepareBuilder();
                result.informedEntity_.Clear();
                return this;
            }

            public Builder SetCause(global::transit_realtime.Alert.Types.Cause value)
            {
                PrepareBuilder();
                result.hasCause = true;
                result.cause_ = value;
                return this;
            }

            public Builder ClearCause()
            {
                PrepareBuilder();
                result.hasCause = false;
                result.cause_ = global::transit_realtime.Alert.Types.Cause.UNKNOWN_CAUSE;
                return this;
            }

            public Builder SetEffect(global::transit_realtime.Alert.Types.Effect value)
            {
                PrepareBuilder();
                result.hasEffect = true;
                result.effect_ = value;
                return this;
            }

            public Builder ClearEffect()
            {
                PrepareBuilder();
                result.hasEffect = false;
                result.effect_ = global::transit_realtime.Alert.Types.Effect.UNKNOWN_EFFECT;
                return this;
            }

            public Builder SetUrl(global::transit_realtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasUrl = true;
                result.url_ = value;
                return this;
            }

            public Builder SetUrl(global::transit_realtime.TranslatedString.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasUrl = true;
                result.url_ = builderForValue.Build();
                return this;
            }

            public Builder MergeUrl(global::transit_realtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasUrl && result.url_ != global::transit_realtime.TranslatedString.DefaultInstance) {
                    result.url_ =
                        global::transit_realtime.TranslatedString.CreateBuilder(result.url_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.url_ = value;
                }
                result.hasUrl = true;
                return this;
            }

            public Builder ClearUrl()
            {
                PrepareBuilder();
                result.hasUrl = false;
                result.url_ = null;
                return this;
            }

            public Builder SetHeaderText(global::transit_realtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasHeaderText = true;
                result.headerText_ = value;
                return this;
            }

            public Builder SetHeaderText(global::transit_realtime.TranslatedString.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasHeaderText = true;
                result.headerText_ = builderForValue.Build();
                return this;
            }

            public Builder MergeHeaderText(global::transit_realtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasHeaderText &&
                    result.headerText_ != global::transit_realtime.TranslatedString.DefaultInstance) {
                    result.headerText_ =
                        global::transit_realtime.TranslatedString.CreateBuilder(result.headerText_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.headerText_ = value;
                }
                result.hasHeaderText = true;
                return this;
            }

            public Builder ClearHeaderText()
            {
                PrepareBuilder();
                result.hasHeaderText = false;
                result.headerText_ = null;
                return this;
            }

            public Builder SetDescriptionText(global::transit_realtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasDescriptionText = true;
                result.descriptionText_ = value;
                return this;
            }

            public Builder SetDescriptionText(global::transit_realtime.TranslatedString.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasDescriptionText = true;
                result.descriptionText_ = builderForValue.Build();
                return this;
            }

            public Builder MergeDescriptionText(global::transit_realtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasDescriptionText &&
                    result.descriptionText_ != global::transit_realtime.TranslatedString.DefaultInstance) {
                    result.descriptionText_ =
                        global::transit_realtime.TranslatedString.CreateBuilder(result.descriptionText_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.descriptionText_ = value;
                }
                result.hasDescriptionText = true;
                return this;
            }

            public Builder ClearDescriptionText()
            {
                PrepareBuilder();
                result.hasDescriptionText = false;
                result.descriptionText_ = null;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TimeRange : pb::GeneratedMessage<TimeRange, TimeRange.Builder>
    {
        public const int StartFieldNumber = 1;
        public const int EndFieldNumber = 2;
        private static readonly TimeRange defaultInstance = new TimeRange().MakeReadOnly();
        private static readonly string[] _timeRangeFieldNames = new string[] {"end", "start"};
        private static readonly uint[] _timeRangeFieldTags = new uint[] {16, 8};
        private ulong end_;
        private bool hasEnd;
        private bool hasStart;
        private int memoizedSerializedSize = -1;
        private ulong start_;

        static TimeRange()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private TimeRange()
        {}

        public static TimeRange DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TimeRange DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TimeRange ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_TimeRange__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TimeRange, TimeRange.Builder> InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_TimeRange__FieldAccessorTable;
            }
        }

        public bool HasStart
        {
            get { return hasStart; }
        }

        [global::System.CLSCompliant(false)]
        public ulong Start
        {
            get { return start_; }
        }

        public bool HasEnd
        {
            get { return hasEnd; }
        }

        [global::System.CLSCompliant(false)]
        public ulong End
        {
            get { return end_; }
        }

        public override bool IsInitialized
        {
            get { return true; }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasStart) {
                    size += pb::CodedOutputStream.ComputeUInt64Size(1, Start);
                }
                if (hasEnd) {
                    size += pb::CodedOutputStream.ComputeUInt64Size(2, End);
                }
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _timeRangeFieldNames;
            if (hasStart) {
                output.WriteUInt64(1, field_names[1], Start);
            }
            if (hasEnd) {
                output.WriteUInt64(2, field_names[0], End);
            }
            UnknownFields.WriteTo(output);
        }

        public static TimeRange ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TimeRange ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TimeRange ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TimeRange ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TimeRange ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TimeRange ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static TimeRange ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static TimeRange ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static TimeRange ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TimeRange ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private TimeRange MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(TimeRange prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<TimeRange, Builder>
        {
            private TimeRange result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(TimeRange cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TimeRange MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override TimeRange DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasStart
            {
                get { return result.hasStart; }
            }

            [global::System.CLSCompliant(false)]
            public ulong Start
            {
                get { return result.Start; }
                set { SetStart(value); }
            }

            public bool HasEnd
            {
                get { return result.hasEnd; }
            }

            [global::System.CLSCompliant(false)]
            public ulong End
            {
                get { return result.End; }
                set { SetEnd(value); }
            }

            private TimeRange PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    TimeRange original = result;
                    result = new TimeRange();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override TimeRange BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TimeRange) {
                    return MergeFrom((TimeRange) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TimeRange other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasStart) {
                    Start = other.Start;
                }
                if (other.HasEnd) {
                    End = other.End;
                }
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_timeRangeFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _timeRangeFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 8:
                        {
                            result.hasStart = input.ReadUInt64(ref result.start_);
                            break;
                        }
                        case 16:
                        {
                            result.hasEnd = input.ReadUInt64(ref result.end_);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            [global::System.CLSCompliant(false)]
            public Builder SetStart(ulong value)
            {
                PrepareBuilder();
                result.hasStart = true;
                result.start_ = value;
                return this;
            }

            public Builder ClearStart()
            {
                PrepareBuilder();
                result.hasStart = false;
                result.start_ = 0UL;
                return this;
            }

            [global::System.CLSCompliant(false)]
            public Builder SetEnd(ulong value)
            {
                PrepareBuilder();
                result.hasEnd = true;
                result.end_ = value;
                return this;
            }

            public Builder ClearEnd()
            {
                PrepareBuilder();
                result.hasEnd = false;
                result.end_ = 0UL;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Position : pb::ExtendableMessage<Position, Position.Builder>
    {
        public const int LatitudeFieldNumber = 1;
        public const int LongitudeFieldNumber = 2;
        public const int BearingFieldNumber = 3;
        public const int OdometerFieldNumber = 4;
        public const int SpeedFieldNumber = 5;
        private static readonly Position defaultInstance = new Position().MakeReadOnly();

        private static readonly string[] _positionFieldNames = new string[]
        {"bearing", "latitude", "longitude", "odometer", "speed"};

        private static readonly uint[] _positionFieldTags = new uint[] {29, 13, 21, 33, 45};
        private float bearing_;
        private bool hasBearing;
        private bool hasLatitude;
        private bool hasLongitude;
        private bool hasOdometer;
        private bool hasSpeed;
        private float latitude_;
        private float longitude_;
        private int memoizedSerializedSize = -1;
        private double odometer_;
        private float speed_;

        static Position()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private Position()
        {}

        public static Position DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override Position DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override Position ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_Position__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<Position, Position.Builder> InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_Position__FieldAccessorTable;
            }
        }

        public bool HasLatitude
        {
            get { return hasLatitude; }
        }

        public float Latitude
        {
            get { return latitude_; }
        }

        public bool HasLongitude
        {
            get { return hasLongitude; }
        }

        public float Longitude
        {
            get { return longitude_; }
        }

        public bool HasBearing
        {
            get { return hasBearing; }
        }

        public float Bearing
        {
            get { return bearing_; }
        }

        public bool HasOdometer
        {
            get { return hasOdometer; }
        }

        public double Odometer
        {
            get { return odometer_; }
        }

        public bool HasSpeed
        {
            get { return hasSpeed; }
        }

        public float Speed
        {
            get { return speed_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasLatitude) {
                    return false;
                }
                if (!hasLongitude) {
                    return false;
                }
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasLatitude) {
                    size += pb::CodedOutputStream.ComputeFloatSize(1, Latitude);
                }
                if (hasLongitude) {
                    size += pb::CodedOutputStream.ComputeFloatSize(2, Longitude);
                }
                if (hasBearing) {
                    size += pb::CodedOutputStream.ComputeFloatSize(3, Bearing);
                }
                if (hasOdometer) {
                    size += pb::CodedOutputStream.ComputeDoubleSize(4, Odometer);
                }
                if (hasSpeed) {
                    size += pb::CodedOutputStream.ComputeFloatSize(5, Speed);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _positionFieldNames;
            pb::ExtendableMessage<Position, Position.Builder>.ExtensionWriter extensionWriter =
                CreateExtensionWriter(this);
            if (hasLatitude) {
                output.WriteFloat(1, field_names[1], Latitude);
            }
            if (hasLongitude) {
                output.WriteFloat(2, field_names[2], Longitude);
            }
            if (hasBearing) {
                output.WriteFloat(3, field_names[0], Bearing);
            }
            if (hasOdometer) {
                output.WriteDouble(4, field_names[3], Odometer);
            }
            if (hasSpeed) {
                output.WriteFloat(5, field_names[4], Speed);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static Position ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static Position ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static Position ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static Position ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static Position ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static Position ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static Position ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static Position ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static Position ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static Position ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private Position MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(Position prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<Position, Builder>
        {
            private Position result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(Position cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override Position MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override Position DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasLatitude
            {
                get { return result.hasLatitude; }
            }

            public float Latitude
            {
                get { return result.Latitude; }
                set { SetLatitude(value); }
            }

            public bool HasLongitude
            {
                get { return result.hasLongitude; }
            }

            public float Longitude
            {
                get { return result.Longitude; }
                set { SetLongitude(value); }
            }

            public bool HasBearing
            {
                get { return result.hasBearing; }
            }

            public float Bearing
            {
                get { return result.Bearing; }
                set { SetBearing(value); }
            }

            public bool HasOdometer
            {
                get { return result.hasOdometer; }
            }

            public double Odometer
            {
                get { return result.Odometer; }
                set { SetOdometer(value); }
            }

            public bool HasSpeed
            {
                get { return result.hasSpeed; }
            }

            public float Speed
            {
                get { return result.Speed; }
                set { SetSpeed(value); }
            }

            private Position PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    Position original = result;
                    result = new Position();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override Position BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is Position) {
                    return MergeFrom((Position) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(Position other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasLatitude) {
                    Latitude = other.Latitude;
                }
                if (other.HasLongitude) {
                    Longitude = other.Longitude;
                }
                if (other.HasBearing) {
                    Bearing = other.Bearing;
                }
                if (other.HasOdometer) {
                    Odometer = other.Odometer;
                }
                if (other.HasSpeed) {
                    Speed = other.Speed;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_positionFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _positionFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 13:
                        {
                            result.hasLatitude = input.ReadFloat(ref result.latitude_);
                            break;
                        }
                        case 21:
                        {
                            result.hasLongitude = input.ReadFloat(ref result.longitude_);
                            break;
                        }
                        case 29:
                        {
                            result.hasBearing = input.ReadFloat(ref result.bearing_);
                            break;
                        }
                        case 33:
                        {
                            result.hasOdometer = input.ReadDouble(ref result.odometer_);
                            break;
                        }
                        case 45:
                        {
                            result.hasSpeed = input.ReadFloat(ref result.speed_);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetLatitude(float value)
            {
                PrepareBuilder();
                result.hasLatitude = true;
                result.latitude_ = value;
                return this;
            }

            public Builder ClearLatitude()
            {
                PrepareBuilder();
                result.hasLatitude = false;
                result.latitude_ = 0F;
                return this;
            }

            public Builder SetLongitude(float value)
            {
                PrepareBuilder();
                result.hasLongitude = true;
                result.longitude_ = value;
                return this;
            }

            public Builder ClearLongitude()
            {
                PrepareBuilder();
                result.hasLongitude = false;
                result.longitude_ = 0F;
                return this;
            }

            public Builder SetBearing(float value)
            {
                PrepareBuilder();
                result.hasBearing = true;
                result.bearing_ = value;
                return this;
            }

            public Builder ClearBearing()
            {
                PrepareBuilder();
                result.hasBearing = false;
                result.bearing_ = 0F;
                return this;
            }

            public Builder SetOdometer(double value)
            {
                PrepareBuilder();
                result.hasOdometer = true;
                result.odometer_ = value;
                return this;
            }

            public Builder ClearOdometer()
            {
                PrepareBuilder();
                result.hasOdometer = false;
                result.odometer_ = 0D;
                return this;
            }

            public Builder SetSpeed(float value)
            {
                PrepareBuilder();
                result.hasSpeed = true;
                result.speed_ = value;
                return this;
            }

            public Builder ClearSpeed()
            {
                PrepareBuilder();
                result.hasSpeed = false;
                result.speed_ = 0F;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TripDescriptor : pb::ExtendableMessage<TripDescriptor, TripDescriptor.Builder>
    {
        public const int TripIdFieldNumber = 1;
        public const int RouteIdFieldNumber = 5;
        public const int StartTimeFieldNumber = 2;
        public const int StartDateFieldNumber = 3;
        public const int ScheduleRelationshipFieldNumber = 4;
        private static readonly TripDescriptor defaultInstance = new TripDescriptor().MakeReadOnly();

        private static readonly string[] _tripDescriptorFieldNames = new string[]
        {"route_id", "schedule_relationship", "start_date", "start_time", "trip_id"};

        private static readonly uint[] _tripDescriptorFieldTags = new uint[] {42, 32, 26, 18, 10};
        private bool hasRouteId;
        private bool hasScheduleRelationship;
        private bool hasStartDate;
        private bool hasStartTime;
        private bool hasTripId;
        private int memoizedSerializedSize = -1;
        private string routeId_ = "";

        private global::transit_realtime.TripDescriptor.Types.ScheduleRelationship scheduleRelationship_ =
            global::transit_realtime.TripDescriptor.Types.ScheduleRelationship.SCHEDULED;

        private string startDate_ = "";
        private string startTime_ = "";
        private string tripId_ = "";

        static TripDescriptor()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private TripDescriptor()
        {}

        public static TripDescriptor DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TripDescriptor DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TripDescriptor ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_TripDescriptor__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TripDescriptor, TripDescriptor.Builder>
            InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_TripDescriptor__FieldAccessorTable;
            }
        }

        public bool HasTripId
        {
            get { return hasTripId; }
        }

        public string TripId
        {
            get { return tripId_; }
        }

        public bool HasRouteId
        {
            get { return hasRouteId; }
        }

        public string RouteId
        {
            get { return routeId_; }
        }

        public bool HasStartTime
        {
            get { return hasStartTime; }
        }

        public string StartTime
        {
            get { return startTime_; }
        }

        public bool HasStartDate
        {
            get { return hasStartDate; }
        }

        public string StartDate
        {
            get { return startDate_; }
        }

        public bool HasScheduleRelationship
        {
            get { return hasScheduleRelationship; }
        }

        public global::transit_realtime.TripDescriptor.Types.ScheduleRelationship ScheduleRelationship
        {
            get { return scheduleRelationship_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasTripId) {
                    size += pb::CodedOutputStream.ComputeStringSize(1, TripId);
                }
                if (hasRouteId) {
                    size += pb::CodedOutputStream.ComputeStringSize(5, RouteId);
                }
                if (hasStartTime) {
                    size += pb::CodedOutputStream.ComputeStringSize(2, StartTime);
                }
                if (hasStartDate) {
                    size += pb::CodedOutputStream.ComputeStringSize(3, StartDate);
                }
                if (hasScheduleRelationship) {
                    size += pb::CodedOutputStream.ComputeEnumSize(4, (int) ScheduleRelationship);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        #region Nested types

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum ScheduleRelationship
            {
                SCHEDULED = 0,
                ADDED = 1,
                UNSCHEDULED = 2,
                CANCELED = 3,
                REPLACEMENT = 5,
            }
        }

        #endregion

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _tripDescriptorFieldNames;
            pb::ExtendableMessage<TripDescriptor, TripDescriptor.Builder>.ExtensionWriter extensionWriter =
                CreateExtensionWriter(this);
            if (hasTripId) {
                output.WriteString(1, field_names[4], TripId);
            }
            if (hasStartTime) {
                output.WriteString(2, field_names[3], StartTime);
            }
            if (hasStartDate) {
                output.WriteString(3, field_names[2], StartDate);
            }
            if (hasScheduleRelationship) {
                output.WriteEnum(4, field_names[1], (int) ScheduleRelationship, ScheduleRelationship);
            }
            if (hasRouteId) {
                output.WriteString(5, field_names[0], RouteId);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static TripDescriptor ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TripDescriptor ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TripDescriptor ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TripDescriptor ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TripDescriptor ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TripDescriptor ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static TripDescriptor ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static TripDescriptor ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static TripDescriptor ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TripDescriptor ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private TripDescriptor MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(TripDescriptor prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<TripDescriptor, Builder>
        {
            private TripDescriptor result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(TripDescriptor cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TripDescriptor MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override TripDescriptor DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasTripId
            {
                get { return result.hasTripId; }
            }

            public string TripId
            {
                get { return result.TripId; }
                set { SetTripId(value); }
            }

            public bool HasRouteId
            {
                get { return result.hasRouteId; }
            }

            public string RouteId
            {
                get { return result.RouteId; }
                set { SetRouteId(value); }
            }

            public bool HasStartTime
            {
                get { return result.hasStartTime; }
            }

            public string StartTime
            {
                get { return result.StartTime; }
                set { SetStartTime(value); }
            }

            public bool HasStartDate
            {
                get { return result.hasStartDate; }
            }

            public string StartDate
            {
                get { return result.StartDate; }
                set { SetStartDate(value); }
            }

            public bool HasScheduleRelationship
            {
                get { return result.hasScheduleRelationship; }
            }

            public global::transit_realtime.TripDescriptor.Types.ScheduleRelationship ScheduleRelationship
            {
                get { return result.ScheduleRelationship; }
                set { SetScheduleRelationship(value); }
            }

            private TripDescriptor PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    TripDescriptor original = result;
                    result = new TripDescriptor();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override TripDescriptor BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TripDescriptor) {
                    return MergeFrom((TripDescriptor) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TripDescriptor other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasTripId) {
                    TripId = other.TripId;
                }
                if (other.HasRouteId) {
                    RouteId = other.RouteId;
                }
                if (other.HasStartTime) {
                    StartTime = other.StartTime;
                }
                if (other.HasStartDate) {
                    StartDate = other.StartDate;
                }
                if (other.HasScheduleRelationship) {
                    ScheduleRelationship = other.ScheduleRelationship;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_tripDescriptorFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _tripDescriptorFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            result.hasTripId = input.ReadString(ref result.tripId_);
                            break;
                        }
                        case 18:
                        {
                            result.hasStartTime = input.ReadString(ref result.startTime_);
                            break;
                        }
                        case 26:
                        {
                            result.hasStartDate = input.ReadString(ref result.startDate_);
                            break;
                        }
                        case 32:
                        {
                            object unknown;
                            if (input.ReadEnum(ref result.scheduleRelationship_, out unknown)) {
                                result.hasScheduleRelationship = true;
                            } else if (unknown is int) {
                                if (unknownFields == null) {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                unknownFields.MergeVarintField(4, (ulong) (int) unknown);
                            }
                            break;
                        }
                        case 42:
                        {
                            result.hasRouteId = input.ReadString(ref result.routeId_);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetTripId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTripId = true;
                result.tripId_ = value;
                return this;
            }

            public Builder ClearTripId()
            {
                PrepareBuilder();
                result.hasTripId = false;
                result.tripId_ = "";
                return this;
            }

            public Builder SetRouteId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasRouteId = true;
                result.routeId_ = value;
                return this;
            }

            public Builder ClearRouteId()
            {
                PrepareBuilder();
                result.hasRouteId = false;
                result.routeId_ = "";
                return this;
            }

            public Builder SetStartTime(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStartTime = true;
                result.startTime_ = value;
                return this;
            }

            public Builder ClearStartTime()
            {
                PrepareBuilder();
                result.hasStartTime = false;
                result.startTime_ = "";
                return this;
            }

            public Builder SetStartDate(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStartDate = true;
                result.startDate_ = value;
                return this;
            }

            public Builder ClearStartDate()
            {
                PrepareBuilder();
                result.hasStartDate = false;
                result.startDate_ = "";
                return this;
            }

            public Builder SetScheduleRelationship(
                global::transit_realtime.TripDescriptor.Types.ScheduleRelationship value)
            {
                PrepareBuilder();
                result.hasScheduleRelationship = true;
                result.scheduleRelationship_ = value;
                return this;
            }

            public Builder ClearScheduleRelationship()
            {
                PrepareBuilder();
                result.hasScheduleRelationship = false;
                result.scheduleRelationship_ =
                    global::transit_realtime.TripDescriptor.Types.ScheduleRelationship.SCHEDULED;
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class VehicleDescriptor : pb::ExtendableMessage<VehicleDescriptor, VehicleDescriptor.Builder>
    {
        public const int IdFieldNumber = 1;
        public const int LabelFieldNumber = 2;
        public const int LicensePlateFieldNumber = 3;
        private static readonly VehicleDescriptor defaultInstance = new VehicleDescriptor().MakeReadOnly();
        private static readonly string[] _vehicleDescriptorFieldNames = new string[] {"id", "label", "license_plate"};
        private static readonly uint[] _vehicleDescriptorFieldTags = new uint[] {10, 18, 26};
        private bool hasId;
        private bool hasLabel;
        private bool hasLicensePlate;
        private string id_ = "";
        private string label_ = "";
        private string licensePlate_ = "";
        private int memoizedSerializedSize = -1;

        static VehicleDescriptor()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private VehicleDescriptor()
        {}

        public static VehicleDescriptor DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override VehicleDescriptor DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override VehicleDescriptor ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_VehicleDescriptor__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<VehicleDescriptor, VehicleDescriptor.Builder>
            InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_VehicleDescriptor__FieldAccessorTable;
            }
        }

        public bool HasId
        {
            get { return hasId; }
        }

        public string Id
        {
            get { return id_; }
        }

        public bool HasLabel
        {
            get { return hasLabel; }
        }

        public string Label
        {
            get { return label_; }
        }

        public bool HasLicensePlate
        {
            get { return hasLicensePlate; }
        }

        public string LicensePlate
        {
            get { return licensePlate_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasId) {
                    size += pb::CodedOutputStream.ComputeStringSize(1, Id);
                }
                if (hasLabel) {
                    size += pb::CodedOutputStream.ComputeStringSize(2, Label);
                }
                if (hasLicensePlate) {
                    size += pb::CodedOutputStream.ComputeStringSize(3, LicensePlate);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _vehicleDescriptorFieldNames;
            pb::ExtendableMessage<VehicleDescriptor, VehicleDescriptor.Builder>.ExtensionWriter extensionWriter =
                CreateExtensionWriter(this);
            if (hasId) {
                output.WriteString(1, field_names[0], Id);
            }
            if (hasLabel) {
                output.WriteString(2, field_names[1], Label);
            }
            if (hasLicensePlate) {
                output.WriteString(3, field_names[2], LicensePlate);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static VehicleDescriptor ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static VehicleDescriptor ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static VehicleDescriptor ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static VehicleDescriptor ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static VehicleDescriptor ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static VehicleDescriptor ParseFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static VehicleDescriptor ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static VehicleDescriptor ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static VehicleDescriptor ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static VehicleDescriptor ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private VehicleDescriptor MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(VehicleDescriptor prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<VehicleDescriptor, Builder>
        {
            private VehicleDescriptor result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(VehicleDescriptor cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override VehicleDescriptor MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override VehicleDescriptor DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasId
            {
                get { return result.hasId; }
            }

            public string Id
            {
                get { return result.Id; }
                set { SetId(value); }
            }

            public bool HasLabel
            {
                get { return result.hasLabel; }
            }

            public string Label
            {
                get { return result.Label; }
                set { SetLabel(value); }
            }

            public bool HasLicensePlate
            {
                get { return result.hasLicensePlate; }
            }

            public string LicensePlate
            {
                get { return result.LicensePlate; }
                set { SetLicensePlate(value); }
            }

            private VehicleDescriptor PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    VehicleDescriptor original = result;
                    result = new VehicleDescriptor();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override VehicleDescriptor BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is VehicleDescriptor) {
                    return MergeFrom((VehicleDescriptor) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(VehicleDescriptor other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasId) {
                    Id = other.Id;
                }
                if (other.HasLabel) {
                    Label = other.Label;
                }
                if (other.HasLicensePlate) {
                    LicensePlate = other.LicensePlate;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_vehicleDescriptorFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _vehicleDescriptorFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            result.hasId = input.ReadString(ref result.id_);
                            break;
                        }
                        case 18:
                        {
                            result.hasLabel = input.ReadString(ref result.label_);
                            break;
                        }
                        case 26:
                        {
                            result.hasLicensePlate = input.ReadString(ref result.licensePlate_);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasId = true;
                result.id_ = value;
                return this;
            }

            public Builder ClearId()
            {
                PrepareBuilder();
                result.hasId = false;
                result.id_ = "";
                return this;
            }

            public Builder SetLabel(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasLabel = true;
                result.label_ = value;
                return this;
            }

            public Builder ClearLabel()
            {
                PrepareBuilder();
                result.hasLabel = false;
                result.label_ = "";
                return this;
            }

            public Builder SetLicensePlate(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasLicensePlate = true;
                result.licensePlate_ = value;
                return this;
            }

            public Builder ClearLicensePlate()
            {
                PrepareBuilder();
                result.hasLicensePlate = false;
                result.licensePlate_ = "";
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class EntitySelector : pb::ExtendableMessage<EntitySelector, EntitySelector.Builder>
    {
        public const int AgencyIdFieldNumber = 1;
        public const int RouteIdFieldNumber = 2;
        public const int RouteTypeFieldNumber = 3;
        public const int TripFieldNumber = 4;
        public const int StopIdFieldNumber = 5;
        private static readonly EntitySelector defaultInstance = new EntitySelector().MakeReadOnly();

        private static readonly string[] _entitySelectorFieldNames = new string[]
        {"agency_id", "route_id", "route_type", "stop_id", "trip"};

        private static readonly uint[] _entitySelectorFieldTags = new uint[] {10, 18, 24, 42, 34};
        private string agencyId_ = "";
        private bool hasAgencyId;
        private bool hasRouteId;
        private bool hasRouteType;
        private bool hasStopId;
        private bool hasTrip;
        private int memoizedSerializedSize = -1;
        private string routeId_ = "";
        private int routeType_;
        private string stopId_ = "";
        private global::transit_realtime.TripDescriptor trip_;

        static EntitySelector()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private EntitySelector()
        {}

        public static EntitySelector DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override EntitySelector DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override EntitySelector ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_EntitySelector__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<EntitySelector, EntitySelector.Builder>
            InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_EntitySelector__FieldAccessorTable;
            }
        }

        public bool HasAgencyId
        {
            get { return hasAgencyId; }
        }

        public string AgencyId
        {
            get { return agencyId_; }
        }

        public bool HasRouteId
        {
            get { return hasRouteId; }
        }

        public string RouteId
        {
            get { return routeId_; }
        }

        public bool HasRouteType
        {
            get { return hasRouteType; }
        }

        public int RouteType
        {
            get { return routeType_; }
        }

        public bool HasTrip
        {
            get { return hasTrip; }
        }

        public global::transit_realtime.TripDescriptor Trip
        {
            get { return trip_ ?? global::transit_realtime.TripDescriptor.DefaultInstance; }
        }

        public bool HasStopId
        {
            get { return hasStopId; }
        }

        public string StopId
        {
            get { return stopId_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!ExtensionsAreInitialized) {
                    return false;
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                if (hasAgencyId) {
                    size += pb::CodedOutputStream.ComputeStringSize(1, AgencyId);
                }
                if (hasRouteId) {
                    size += pb::CodedOutputStream.ComputeStringSize(2, RouteId);
                }
                if (hasRouteType) {
                    size += pb::CodedOutputStream.ComputeInt32Size(3, RouteType);
                }
                if (hasTrip) {
                    size += pb::CodedOutputStream.ComputeMessageSize(4, Trip);
                }
                if (hasStopId) {
                    size += pb::CodedOutputStream.ComputeStringSize(5, StopId);
                }
                size += ExtensionsSerializedSize;
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _entitySelectorFieldNames;
            pb::ExtendableMessage<EntitySelector, EntitySelector.Builder>.ExtensionWriter extensionWriter =
                CreateExtensionWriter(this);
            if (hasAgencyId) {
                output.WriteString(1, field_names[0], AgencyId);
            }
            if (hasRouteId) {
                output.WriteString(2, field_names[1], RouteId);
            }
            if (hasRouteType) {
                output.WriteInt32(3, field_names[2], RouteType);
            }
            if (hasTrip) {
                output.WriteMessage(4, field_names[4], Trip);
            }
            if (hasStopId) {
                output.WriteString(5, field_names[3], StopId);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        public static EntitySelector ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static EntitySelector ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static EntitySelector ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static EntitySelector ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static EntitySelector ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static EntitySelector ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static EntitySelector ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static EntitySelector ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static EntitySelector ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static EntitySelector ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private EntitySelector MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(EntitySelector prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<EntitySelector, Builder>
        {
            private EntitySelector result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(EntitySelector cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override EntitySelector MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override EntitySelector DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public bool HasAgencyId
            {
                get { return result.hasAgencyId; }
            }

            public string AgencyId
            {
                get { return result.AgencyId; }
                set { SetAgencyId(value); }
            }

            public bool HasRouteId
            {
                get { return result.hasRouteId; }
            }

            public string RouteId
            {
                get { return result.RouteId; }
                set { SetRouteId(value); }
            }

            public bool HasRouteType
            {
                get { return result.hasRouteType; }
            }

            public int RouteType
            {
                get { return result.RouteType; }
                set { SetRouteType(value); }
            }

            public bool HasTrip
            {
                get { return result.hasTrip; }
            }

            public global::transit_realtime.TripDescriptor Trip
            {
                get { return result.Trip; }
                set { SetTrip(value); }
            }

            public bool HasStopId
            {
                get { return result.hasStopId; }
            }

            public string StopId
            {
                get { return result.StopId; }
                set { SetStopId(value); }
            }

            private EntitySelector PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    EntitySelector original = result;
                    result = new EntitySelector();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override EntitySelector BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is EntitySelector) {
                    return MergeFrom((EntitySelector) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(EntitySelector other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.HasAgencyId) {
                    AgencyId = other.AgencyId;
                }
                if (other.HasRouteId) {
                    RouteId = other.RouteId;
                }
                if (other.HasRouteType) {
                    RouteType = other.RouteType;
                }
                if (other.HasTrip) {
                    MergeTrip(other.Trip);
                }
                if (other.HasStopId) {
                    StopId = other.StopId;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_entitySelectorFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _entitySelectorFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            result.hasAgencyId = input.ReadString(ref result.agencyId_);
                            break;
                        }
                        case 18:
                        {
                            result.hasRouteId = input.ReadString(ref result.routeId_);
                            break;
                        }
                        case 24:
                        {
                            result.hasRouteType = input.ReadInt32(ref result.routeType_);
                            break;
                        }
                        case 34:
                        {
                            global::transit_realtime.TripDescriptor.Builder subBuilder =
                                global::transit_realtime.TripDescriptor.CreateBuilder();
                            if (result.hasTrip) {
                                subBuilder.MergeFrom(Trip);
                            }
                            input.ReadMessage(subBuilder, extensionRegistry);
                            Trip = subBuilder.BuildPartial();
                            break;
                        }
                        case 42:
                        {
                            result.hasStopId = input.ReadString(ref result.stopId_);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public Builder SetAgencyId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasAgencyId = true;
                result.agencyId_ = value;
                return this;
            }

            public Builder ClearAgencyId()
            {
                PrepareBuilder();
                result.hasAgencyId = false;
                result.agencyId_ = "";
                return this;
            }

            public Builder SetRouteId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasRouteId = true;
                result.routeId_ = value;
                return this;
            }

            public Builder ClearRouteId()
            {
                PrepareBuilder();
                result.hasRouteId = false;
                result.routeId_ = "";
                return this;
            }

            public Builder SetRouteType(int value)
            {
                PrepareBuilder();
                result.hasRouteType = true;
                result.routeType_ = value;
                return this;
            }

            public Builder ClearRouteType()
            {
                PrepareBuilder();
                result.hasRouteType = false;
                result.routeType_ = 0;
                return this;
            }

            public Builder SetTrip(global::transit_realtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = value;
                return this;
            }

            public Builder SetTrip(global::transit_realtime.TripDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = builderForValue.Build();
                return this;
            }

            public Builder MergeTrip(global::transit_realtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTrip && result.trip_ != global::transit_realtime.TripDescriptor.DefaultInstance) {
                    result.trip_ =
                        global::transit_realtime.TripDescriptor.CreateBuilder(result.trip_)
                            .MergeFrom(value)
                            .BuildPartial();
                } else {
                    result.trip_ = value;
                }
                result.hasTrip = true;
                return this;
            }

            public Builder ClearTrip()
            {
                PrepareBuilder();
                result.hasTrip = false;
                result.trip_ = null;
                return this;
            }

            public Builder SetStopId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStopId = true;
                result.stopId_ = value;
                return this;
            }

            public Builder ClearStopId()
            {
                PrepareBuilder();
                result.hasStopId = false;
                result.stopId_ = "";
                return this;
            }
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TranslatedString : pb::GeneratedMessage<TranslatedString, TranslatedString.Builder>
    {
        public const int TranslationFieldNumber = 1;
        private static readonly TranslatedString defaultInstance = new TranslatedString().MakeReadOnly();
        private static readonly string[] _translatedStringFieldNames = new string[] {"translation"};
        private static readonly uint[] _translatedStringFieldTags = new uint[] {10};
        private int memoizedSerializedSize = -1;

        private pbc::PopsicleList<global::transit_realtime.TranslatedString.Types.Translation> translation_ =
            new pbc::PopsicleList<global::transit_realtime.TranslatedString.Types.Translation>();

        static TranslatedString()
        {
            ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
        }

        private TranslatedString()
        {}

        public static TranslatedString DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TranslatedString DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TranslatedString ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime.internal__static_transit_realtime_TranslatedString__Descriptor;
            }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TranslatedString, TranslatedString.Builder>
            InternalFieldAccessors
        {
            get
            {
                return
                    global::transit_realtime.Gtfsrealtime
                        .internal__static_transit_realtime_TranslatedString__FieldAccessorTable;
            }
        }

        public scg::IList<global::transit_realtime.TranslatedString.Types.Translation> TranslationList
        {
            get { return translation_; }
        }

        public int TranslationCount
        {
            get { return translation_.Count; }
        }

        public override bool IsInitialized
        {
            get
            {
                foreach (var element in TranslationList) {
                    if (!element.IsInitialized) {
                        return false;
                    }
                }
                return true;
            }
        }

        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) {
                    return size;
                }

                size = 0;
                foreach (var element in TranslationList) {
                    size += pb::CodedOutputStream.ComputeMessageSize(1, element);
                }
                size += UnknownFields.SerializedSize;
                memoizedSerializedSize = size;
                return size;
            }
        }

        #region Nested types

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class Translation : pb::GeneratedMessage<Translation, Translation.Builder>
            {
                public const int TextFieldNumber = 1;
                public const int LanguageFieldNumber = 2;
                private static readonly Translation defaultInstance = new Translation().MakeReadOnly();
                private static readonly string[] _translationFieldNames = new string[] {"language", "text"};
                private static readonly uint[] _translationFieldTags = new uint[] {18, 10};
                private bool hasLanguage;
                private bool hasText;
                private string language_ = "";
                private int memoizedSerializedSize = -1;
                private string text_ = "";

                static Translation()
                {
                    ReferenceEquals(global::transit_realtime.Gtfsrealtime.Descriptor, null);
                }

                private Translation()
                {}

                public static Translation DefaultInstance
                {
                    get { return defaultInstance; }
                }

                public override Translation DefaultInstanceForType
                {
                    get { return DefaultInstance; }
                }

                protected override Translation ThisMessage
                {
                    get { return this; }
                }

                public static pbd::MessageDescriptor Descriptor
                {
                    get
                    {
                        return
                            global::transit_realtime.Gtfsrealtime
                                .internal__static_transit_realtime_TranslatedString_Translation__Descriptor;
                    }
                }

                protected override pb::FieldAccess.FieldAccessorTable<Translation, Translation.Builder>
                    InternalFieldAccessors
                {
                    get
                    {
                        return
                            global::transit_realtime.Gtfsrealtime
                                .internal__static_transit_realtime_TranslatedString_Translation__FieldAccessorTable;
                    }
                }

                public bool HasText
                {
                    get { return hasText; }
                }

                public string Text
                {
                    get { return text_; }
                }

                public bool HasLanguage
                {
                    get { return hasLanguage; }
                }

                public string Language
                {
                    get { return language_; }
                }

                public override bool IsInitialized
                {
                    get
                    {
                        if (!hasText) {
                            return false;
                        }
                        return true;
                    }
                }

                public override int SerializedSize
                {
                    get
                    {
                        int size = memoizedSerializedSize;
                        if (size != -1) {
                            return size;
                        }

                        size = 0;
                        if (hasText) {
                            size += pb::CodedOutputStream.ComputeStringSize(1, Text);
                        }
                        if (hasLanguage) {
                            size += pb::CodedOutputStream.ComputeStringSize(2, Language);
                        }
                        size += UnknownFields.SerializedSize;
                        memoizedSerializedSize = size;
                        return size;
                    }
                }

                public override void WriteTo(pb::ICodedOutputStream output)
                {
                    int size = SerializedSize;
                    string[] field_names = _translationFieldNames;
                    if (hasText) {
                        output.WriteString(1, field_names[1], Text);
                    }
                    if (hasLanguage) {
                        output.WriteString(2, field_names[0], Language);
                    }
                    UnknownFields.WriteTo(output);
                }

                public static Translation ParseFrom(pb::ByteString data)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
                }

                public static Translation ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }

                public static Translation ParseFrom(byte[] data)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
                }

                public static Translation ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }

                public static Translation ParseFrom(global::System.IO.Stream input)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
                }

                public static Translation ParseFrom(global::System.IO.Stream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }

                public static Translation ParseDelimitedFrom(global::System.IO.Stream input)
                {
                    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
                }

                public static Translation ParseDelimitedFrom(global::System.IO.Stream input,
                    pb::ExtensionRegistry extensionRegistry)
                {
                    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
                }

                public static Translation ParseFrom(pb::ICodedInputStream input)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
                }

                public static Translation ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }

                private Translation MakeReadOnly()
                {
                    return this;
                }

                public static Builder CreateBuilder()
                {
                    return new Builder();
                }

                public override Builder ToBuilder()
                {
                    return CreateBuilder(this);
                }

                public override Builder CreateBuilderForType()
                {
                    return new Builder();
                }

                public static Builder CreateBuilder(Translation prototype)
                {
                    return new Builder(prototype);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public sealed partial class Builder : pb::GeneratedBuilder<Translation, Builder>
                {
                    private Translation result;
                    private bool resultIsReadOnly;

                    public Builder()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                    }

                    internal Builder(Translation cloneFrom)
                    {
                        result = cloneFrom;
                        resultIsReadOnly = true;
                    }

                    protected override Builder ThisBuilder
                    {
                        get { return this; }
                    }

                    public override bool IsInitialized
                    {
                        get { return result.IsInitialized; }
                    }

                    protected override Translation MessageBeingBuilt
                    {
                        get { return PrepareBuilder(); }
                    }

                    public override pbd::MessageDescriptor DescriptorForType
                    {
                        get { return Descriptor; }
                    }

                    public override Translation DefaultInstanceForType
                    {
                        get { return DefaultInstance; }
                    }

                    public bool HasText
                    {
                        get { return result.hasText; }
                    }

                    public string Text
                    {
                        get { return result.Text; }
                        set { SetText(value); }
                    }

                    public bool HasLanguage
                    {
                        get { return result.hasLanguage; }
                    }

                    public string Language
                    {
                        get { return result.Language; }
                        set { SetLanguage(value); }
                    }

                    private Translation PrepareBuilder()
                    {
                        if (resultIsReadOnly) {
                            Translation original = result;
                            result = new Translation();
                            resultIsReadOnly = false;
                            MergeFrom(original);
                        }
                        return result;
                    }

                    public override Builder Clear()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                        return this;
                    }

                    public override Builder Clone()
                    {
                        if (resultIsReadOnly) {
                            return new Builder(result);
                        } else {
                            return new Builder().MergeFrom(result);
                        }
                    }

                    public override Translation BuildPartial()
                    {
                        if (resultIsReadOnly) {
                            return result;
                        }
                        resultIsReadOnly = true;
                        return result.MakeReadOnly();
                    }

                    public override Builder MergeFrom(pb::IMessage other)
                    {
                        if (other is Translation) {
                            return MergeFrom((Translation) other);
                        } else {
                            base.MergeFrom(other);
                            return this;
                        }
                    }

                    public override Builder MergeFrom(Translation other)
                    {
                        if (other == DefaultInstance) {
                            return this;
                        }
                        PrepareBuilder();
                        if (other.HasText) {
                            Text = other.Text;
                        }
                        if (other.HasLanguage) {
                            Language = other.Language;
                        }
                        this.MergeUnknownFields(other.UnknownFields);
                        return this;
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input)
                    {
                        return MergeFrom(input, pb::ExtensionRegistry.Empty);
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input,
                        pb::ExtensionRegistry extensionRegistry)
                    {
                        PrepareBuilder();
                        pb::UnknownFieldSet.Builder unknownFields = null;
                        uint tag;
                        string field_name;
                        while (input.ReadTag(out tag, out field_name)) {
                            if (tag == 0 && field_name != null) {
                                int field_ordinal = global::System.Array.BinarySearch(_translationFieldNames, field_name,
                                    global::System.StringComparer.Ordinal);
                                if (field_ordinal >= 0) {
                                    tag = _translationFieldTags[field_ordinal];
                                } else {
                                    if (unknownFields == null) {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    continue;
                                }
                            }
                            switch (tag) {
                                case 0:
                                {
                                    throw pb::InvalidProtocolBufferException.InvalidTag();
                                }
                                default:
                                {
                                    if (pb::WireFormat.IsEndGroupTag(tag)) {
                                        if (unknownFields != null) {
                                            this.UnknownFields = unknownFields.Build();
                                        }
                                        return this;
                                    }
                                    if (unknownFields == null) {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    break;
                                }
                                case 10:
                                {
                                    result.hasText = input.ReadString(ref result.text_);
                                    break;
                                }
                                case 18:
                                {
                                    result.hasLanguage = input.ReadString(ref result.language_);
                                    break;
                                }
                            }
                        }

                        if (unknownFields != null) {
                            this.UnknownFields = unknownFields.Build();
                        }
                        return this;
                    }


                    public Builder SetText(string value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasText = true;
                        result.text_ = value;
                        return this;
                    }

                    public Builder ClearText()
                    {
                        PrepareBuilder();
                        result.hasText = false;
                        result.text_ = "";
                        return this;
                    }

                    public Builder SetLanguage(string value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasLanguage = true;
                        result.language_ = value;
                        return this;
                    }

                    public Builder ClearLanguage()
                    {
                        PrepareBuilder();
                        result.hasLanguage = false;
                        result.language_ = "";
                        return this;
                    }
                }
            }
        }

        #endregion

        public global::transit_realtime.TranslatedString.Types.Translation GetTranslation(int index)
        {
            return translation_[index];
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            int size = SerializedSize;
            string[] field_names = _translatedStringFieldNames;
            if (translation_.Count > 0) {
                output.WriteMessageArray(1, field_names[0], translation_);
            }
            UnknownFields.WriteTo(output);
        }

        public static TranslatedString ParseFrom(pb::ByteString data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TranslatedString ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TranslatedString ParseFrom(byte[] data)
        {
            return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }

        public static TranslatedString ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }

        public static TranslatedString ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TranslatedString ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        public static TranslatedString ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }

        public static TranslatedString ParseDelimitedFrom(global::System.IO.Stream input,
            pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }

        public static TranslatedString ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }

        public static TranslatedString ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }

        private TranslatedString MakeReadOnly()
        {
            translation_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder()
        {
            return new Builder();
        }

        public override Builder ToBuilder()
        {
            return CreateBuilder(this);
        }

        public override Builder CreateBuilderForType()
        {
            return new Builder();
        }

        public static Builder CreateBuilder(TranslatedString prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilder<TranslatedString, Builder>
        {
            private TranslatedString result;
            private bool resultIsReadOnly;

            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }

            internal Builder(TranslatedString cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            protected override Builder ThisBuilder
            {
                get { return this; }
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TranslatedString MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return Descriptor; }
            }

            public override TranslatedString DefaultInstanceForType
            {
                get { return DefaultInstance; }
            }

            public pbc::IPopsicleList<global::transit_realtime.TranslatedString.Types.Translation> TranslationList
            {
                get { return PrepareBuilder().translation_; }
            }

            public int TranslationCount
            {
                get { return result.TranslationCount; }
            }

            private TranslatedString PrepareBuilder()
            {
                if (resultIsReadOnly) {
                    TranslatedString original = result;
                    result = new TranslatedString();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly) {
                    return new Builder(result);
                } else {
                    return new Builder().MergeFrom(result);
                }
            }

            public override TranslatedString BuildPartial()
            {
                if (resultIsReadOnly) {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TranslatedString) {
                    return MergeFrom((TranslatedString) other);
                } else {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TranslatedString other)
            {
                if (other == DefaultInstance) {
                    return this;
                }
                PrepareBuilder();
                if (other.translation_.Count != 0) {
                    result.translation_.Add(other.translation_);
                }
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name)) {
                    if (tag == 0 && field_name != null) {
                        int field_ordinal = global::System.Array.BinarySearch(_translatedStringFieldNames, field_name,
                            global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0) {
                            tag = _translatedStringFieldTags[field_ordinal];
                        } else {
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag) {
                        case 0:
                        {
                            throw pb::InvalidProtocolBufferException.InvalidTag();
                        }
                        default:
                        {
                            if (pb::WireFormat.IsEndGroupTag(tag)) {
                                if (unknownFields != null) {
                                    this.UnknownFields = unknownFields.Build();
                                }
                                return this;
                            }
                            if (unknownFields == null) {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            break;
                        }
                        case 10:
                        {
                            input.ReadMessageArray(tag, field_name, result.translation_,
                                global::transit_realtime.TranslatedString.Types.Translation.DefaultInstance,
                                extensionRegistry);
                            break;
                        }
                    }
                }

                if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public global::transit_realtime.TranslatedString.Types.Translation GetTranslation(int index)
            {
                return result.GetTranslation(index);
            }

            public Builder SetTranslation(int index, global::transit_realtime.TranslatedString.Types.Translation value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.translation_[index] = value;
                return this;
            }

            public Builder SetTranslation(int index,
                global::transit_realtime.TranslatedString.Types.Translation.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.translation_[index] = builderForValue.Build();
                return this;
            }

            public Builder AddTranslation(global::transit_realtime.TranslatedString.Types.Translation value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.translation_.Add(value);
                return this;
            }

            public Builder AddTranslation(
                global::transit_realtime.TranslatedString.Types.Translation.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.translation_.Add(builderForValue.Build());
                return this;
            }

            public Builder AddRangeTranslation(
                scg::IEnumerable<global::transit_realtime.TranslatedString.Types.Translation> values)
            {
                PrepareBuilder();
                result.translation_.Add(values);
                return this;
            }

            public Builder ClearTranslation()
            {
                PrepareBuilder();
                result.translation_.Clear();
                return this;
            }
        }
    }

    #endregion
}

#endregion Designer generated code